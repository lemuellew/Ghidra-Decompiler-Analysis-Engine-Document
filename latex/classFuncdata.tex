\hypertarget{classFuncdata}{}\doxysection{Funcdata Class Reference}
\label{classFuncdata}\index{Funcdata@{Funcdata}}


Container for data structures associated with a single function.  




{\ttfamily \#include $<$funcdata.\+hh$>$}

\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classFuncdata_a979faf589906b1a1937623f7a2a186f2}{Funcdata}} (const string \&nm, \mbox{\hyperlink{classScope}{Scope}} $\ast$conf, const \mbox{\hyperlink{classAddress}{Address}} \&addr, \mbox{\hyperlink{classFunctionSymbol}{Function\+Symbol}} $\ast$sym, int4 sz=0)
\begin{DoxyCompactList}\small\item\em \mbox{\hyperlink{classConstructor}{Constructor}}. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classFuncdata_a0b4fb40eeb52f948ca7a14187a21c7db}\label{classFuncdata_a0b4fb40eeb52f948ca7a14187a21c7db}} 
\mbox{\hyperlink{classFuncdata_a0b4fb40eeb52f948ca7a14187a21c7db}{$\sim$\+Funcdata}} (void)
\begin{DoxyCompactList}\small\item\em Destructor. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classFuncdata_ac33bb4d59a0125d36710fe80453b9526}{set\+Jumptable\+Recovery}} (bool val)
\begin{DoxyCompactList}\small\item\em Toggle whether {\bfseries{this}} is being used for jump-\/table recovery. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classFuncdata_a23bcddc7a3b959812f9a1660b39cc6ef}{set\+Double\+Precis\+Recovery}} (bool val)
\begin{DoxyCompactList}\small\item\em Toggle whether double precision analysis is used. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classFuncdata_a25b616d10d9514eda69dd9d974c62eb8}\label{classFuncdata_a25b616d10d9514eda69dd9d974c62eb8}} 
void \mbox{\hyperlink{classFuncdata_a25b616d10d9514eda69dd9d974c62eb8}{clear}} (void)
\begin{DoxyCompactList}\small\item\em Clear out old disassembly. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classFuncdata_a19698f34a432f84d8cbe94f8e0ad20d4}{warning}} (const string \&txt, const \mbox{\hyperlink{classAddress}{Address}} \&ad) const
\begin{DoxyCompactList}\small\item\em Add a warning comment in the function body. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classFuncdata_a87967b12187406a7fdf311cc4b836118}{warning\+Header}} (const string \&txt) const
\begin{DoxyCompactList}\small\item\em Add a warning comment as part of the function header. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classFuncdata_a0637a2c7f6a1e511284cfeecb4b0d475}{start\+Processing}} (void)
\begin{DoxyCompactList}\small\item\em Start processing for this function. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classFuncdata_a36b7bf9f9ad6a3c56968f4daa9ca27d5}\label{classFuncdata_a36b7bf9f9ad6a3c56968f4daa9ca27d5}} 
void \mbox{\hyperlink{classFuncdata_a36b7bf9f9ad6a3c56968f4daa9ca27d5}{stop\+Processing}} (void)
\begin{DoxyCompactList}\small\item\em Mark that processing has completed for this function. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classFuncdata_a0add0ec99a303d6cdfc5187bb2c768f7}\label{classFuncdata_a0add0ec99a303d6cdfc5187bb2c768f7}} 
bool \mbox{\hyperlink{classFuncdata_a0add0ec99a303d6cdfc5187bb2c768f7}{start\+Type\+Recovery}} (void)
\begin{DoxyCompactList}\small\item\em Mark that data-\/type analysis has started. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classFuncdata_a5c8f8e90f70db000a97d80677cdb133b}{follow\+Flow}} (const \mbox{\hyperlink{classAddress}{Address}} \&baddr, const \mbox{\hyperlink{classAddress}{Address}} \&eadddr)
\begin{DoxyCompactList}\small\item\em Generate raw p-\/code for the function. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classFuncdata_a122718ad87c13b714676c61050461388}{truncated\+Flow}} (const \mbox{\hyperlink{classFuncdata}{Funcdata}} $\ast$fd, const \mbox{\hyperlink{classFlowInfo}{Flow\+Info}} $\ast$flow)
\begin{DoxyCompactList}\small\item\em Generate a clone with truncated control-\/flow given a partial function. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classFuncdata_a3bcc11dc2a2eefa48bc4b244094a521f}{inline\+Flow}} (\mbox{\hyperlink{classFuncdata}{Funcdata}} $\ast$inlinefd, \mbox{\hyperlink{classFlowInfo}{Flow\+Info}} \&flow, \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$callop)
\begin{DoxyCompactList}\small\item\em In-\/line the p-\/code from another function into {\bfseries{this}} function. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classFuncdata_aafb83719ca201b5d57283058e2bcadee}{override\+Flow}} (const \mbox{\hyperlink{classAddress}{Address}} \&addr, uint4 type)
\begin{DoxyCompactList}\small\item\em \mbox{\hyperlink{classOverride}{Override}} the control-\/flow p-\/code for a particular instruction. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classFuncdata_adb1dd79d78141f89d374e570de21d690}{do\+Live\+Inject}} (\mbox{\hyperlink{classInjectPayload}{Inject\+Payload}} $\ast$payload, const \mbox{\hyperlink{classAddress}{Address}} \&addr, \mbox{\hyperlink{classBlockBasic}{Block\+Basic}} $\ast$bl, list$<$ \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$ $>$\+::iterator pos)
\begin{DoxyCompactList}\small\item\em Inject p-\/code from a {\itshape payload} into {\bfseries{this}} live function. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classFuncdata_a9a3cdbf385c382c10fc5b48f5842b418}{print\+Raw}} (ostream \&s) const
\begin{DoxyCompactList}\small\item\em Print raw p-\/code op descriptions to a stream. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classFuncdata_ac150948163b641a4d138ef82bf213f4e}{print\+Varnode\+Tree}} (ostream \&s) const
\begin{DoxyCompactList}\small\item\em Print a description of all Varnodes to a stream. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classFuncdata_a8c86861b22f4beb1cac5ab3ab43db6ae}{print\+Block\+Tree}} (ostream \&s) const
\begin{DoxyCompactList}\small\item\em Print a description of control-\/flow structuring to a stream. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classFuncdata_a2b52d8ec8b53529b02881977971067ce}{print\+Local\+Range}} (ostream \&s) const
\begin{DoxyCompactList}\small\item\em Print description of memory ranges associated with local scopes. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classFuncdata_ac8e7664bd70368066f7ad70a8922795e}{save\+Xml}} (ostream \&s, uint8 id, bool savetree) const
\begin{DoxyCompactList}\small\item\em Emit an X\+ML description of {\bfseries{this}} function to stream. \end{DoxyCompactList}\item 
uint8 \mbox{\hyperlink{classFuncdata_a7419de8057421b8e9300c4a26c60ecef}{restore\+Xml}} (const \mbox{\hyperlink{classElement}{Element}} $\ast$el)
\begin{DoxyCompactList}\small\item\em Restore the state of {\bfseries{this}} function from an X\+ML description. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classFuncdata_a5f2d5d66f0ae7c5c4eae20d60ad30897}{save\+Xml\+Jump\+Table}} (ostream \&s) const
\begin{DoxyCompactList}\small\item\em Emit an X\+ML description of jump-\/tables to stream. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classFuncdata_a07a41bb91dd51c9a76d8f6d1e2f09328}{restore\+Xml\+Jump\+Table}} (const \mbox{\hyperlink{classElement}{Element}} $\ast$el)
\begin{DoxyCompactList}\small\item\em Restore jump-\/tables from an X\+ML description. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classFuncdata_a7630153130424a56fac5a4b4a4792b60}{save\+Xml\+Tree}} (ostream \&s) const
\begin{DoxyCompactList}\small\item\em Save an X\+ML description of the p-\/code tree to stream. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classFuncdata_accde64f2642f6e86545df826e2751f8b}{save\+Xml\+High}} (ostream \&s) const
\begin{DoxyCompactList}\small\item\em Save an X\+ML description of all High\+Variables to stream. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classFuncdata_af21c852eb9f606c5cd19fb2456927ecd}{set\+Restart\+Pending}} (bool val)
\begin{DoxyCompactList}\small\item\em Toggle whether analysis needs to be restarted for {\bfseries{this}} function. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classFuncdata_ae349f4a44febd9dd27ca63f7f8840103}{has\+Restart\+Pending}} (void) const
\begin{DoxyCompactList}\small\item\em Does {\bfseries{this}} function need to restart its analysis. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classFuncdata_afef27da9040d28296accaaa1c1982401}{has\+Unimplemented}} (void) const
\begin{DoxyCompactList}\small\item\em Does {\bfseries{this}} function have instructions marked as {\itshape unimplemented}. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classFuncdata_a96433773ee0126ce9a25b0970a6ef513}{spacebase}} (void)
\begin{DoxyCompactList}\small\item\em Mark registers that map to a virtual address space. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classVarnode}{Varnode}} $\ast$ \mbox{\hyperlink{classFuncdata_ac083b7d6637a5883ef8cbd38e7756837}{new\+Spacebase\+Ptr}} (\mbox{\hyperlink{classAddrSpace}{Addr\+Space}} $\ast$id)
\begin{DoxyCompactList}\small\item\em Construct a new {\itshape spacebase} register for a given address space. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classVarnode}{Varnode}} $\ast$ \mbox{\hyperlink{classFuncdata_a1eee1ea3fa8e72d17549a936567c97bf}{find\+Spacebase\+Input}} (\mbox{\hyperlink{classAddrSpace}{Addr\+Space}} $\ast$id) const
\item 
void \mbox{\hyperlink{classFuncdata_aaf4a89f4e3da37a4107992689f7b89ff}{spacebase\+Constant}} (\mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$op, int4 slot, \mbox{\hyperlink{classSymbolEntry}{Symbol\+Entry}} $\ast$entry, const \mbox{\hyperlink{classAddress}{Address}} \&rampoint, uintb origval, int4 origsize)
\begin{DoxyCompactList}\small\item\em Convert a constant pointer into a {\itshape ram} C\+P\+U\+I\+\_\+\+P\+T\+R\+S\+UB. \end{DoxyCompactList}\item 
int4 \mbox{\hyperlink{classFuncdata_a363bd02cb2f20cf1583951d5429a057b}{num\+Heritage\+Passes}} (\mbox{\hyperlink{classAddrSpace}{Addr\+Space}} $\ast$spc)
\begin{DoxyCompactList}\small\item\em Get the number of heritage passes performed for the given address space. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classFuncdata_adc0c8b4dab63367913749e68fbd33789}{seen\+Deadcode}} (\mbox{\hyperlink{classAddrSpace}{Addr\+Space}} $\ast$spc)
\begin{DoxyCompactList}\small\item\em Mark that dead Varnodes have been seen in a specific address space. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classFuncdata_ac40aef88ca7a101e4697df5e0ec5f605}{set\+Dead\+Code\+Delay}} (\mbox{\hyperlink{classAddrSpace}{Addr\+Space}} $\ast$spc, int4 delay)
\begin{DoxyCompactList}\small\item\em Set a delay before removing dead code for a specific address space. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classFuncdata_adaf432bbbd299e976c8f02fc97fb3dbe}{dead\+Removal\+Allowed}} (\mbox{\hyperlink{classAddrSpace}{Addr\+Space}} $\ast$spc) const
\begin{DoxyCompactList}\small\item\em Check if dead code removal is allowed for a specific address space. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classFuncdata_adba7696040378f0eaa679e684b72bf96}{dead\+Removal\+Allowed\+Seen}} (\mbox{\hyperlink{classAddrSpace}{Addr\+Space}} $\ast$spc)
\begin{DoxyCompactList}\small\item\em Check if dead Varnodes have been removed for a specific address space. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classFuncdata_a803cbb38fe59825f59858a16afa54b7d}{is\+Heritaged}} (\mbox{\hyperlink{classVarnode}{Varnode}} $\ast$vn)
\begin{DoxyCompactList}\small\item\em Check if a specific \mbox{\hyperlink{classVarnode}{Varnode}} has been linked in fully to the syntax tree (S\+SA) \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classFuncdata_a952f07a6db222c00cc243917767dcdc1}\label{classFuncdata_a952f07a6db222c00cc243917767dcdc1}} 
\mbox{\hyperlink{classFuncCallSpecs}{Func\+Call\+Specs}} $\ast$ \mbox{\hyperlink{classFuncdata_a952f07a6db222c00cc243917767dcdc1}{get\+Call\+Specs}} (const \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$op) const
\begin{DoxyCompactList}\small\item\em Get the call specification associated with a C\+A\+LL op. \end{DoxyCompactList}\item 
int4 \mbox{\hyperlink{classFuncdata_a142938fffbfd5add2b6679a6b9b0d7fa}{fillin\+Extrapop}} (void)
\begin{DoxyCompactList}\small\item\em Recover and return the {\itshape extrapop} for this function. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classVarnode}{Varnode}} $\ast$ \mbox{\hyperlink{classFuncdata_a100e6704e4c245e076170268d31b47ec}{new\+Varnode\+Out}} (int4 s, const \mbox{\hyperlink{classAddress}{Address}} \&m, \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$op)
\begin{DoxyCompactList}\small\item\em Create a new output \mbox{\hyperlink{classVarnode}{Varnode}}. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classVarnode}{Varnode}} $\ast$ \mbox{\hyperlink{classFuncdata_af189a9a5b390332c6e87c8faa334cd68}{new\+Unique\+Out}} (int4 s, \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$op)
\begin{DoxyCompactList}\small\item\em Create a new {\itshape temporary} output \mbox{\hyperlink{classVarnode}{Varnode}}. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classVarnode}{Varnode}} $\ast$ \mbox{\hyperlink{classFuncdata_a22894e1c7b0f30a5391993924cd96d3d}{new\+Varnode}} (int4 s, const \mbox{\hyperlink{classAddress}{Address}} \&m, \mbox{\hyperlink{classDatatype}{Datatype}} $\ast$ct=(\mbox{\hyperlink{classDatatype}{Datatype}} $\ast$) 0)
\begin{DoxyCompactList}\small\item\em Create a new unattached \mbox{\hyperlink{classVarnode}{Varnode}} object. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classVarnode}{Varnode}} $\ast$ \mbox{\hyperlink{classFuncdata_af58542dbcc89f4b84ffc8834b023125b}{new\+Constant}} (int4 s, uintb constant\+\_\+val)
\begin{DoxyCompactList}\small\item\em Create a new {\itshape constant} \mbox{\hyperlink{classVarnode}{Varnode}}. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classVarnode}{Varnode}} $\ast$ \mbox{\hyperlink{classFuncdata_a0d6888d1606fd8ed6372355995bc7887}{new\+Varnode}} (int4 s, \mbox{\hyperlink{classAddrSpace}{Addr\+Space}} $\ast$base, uintb off)
\begin{DoxyCompactList}\small\item\em Create a new \mbox{\hyperlink{classVarnode}{Varnode}} given an address space and offset. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classVarnode}{Varnode}} $\ast$ \mbox{\hyperlink{classFuncdata_a8ee39fe2d1f2f4702864e78dc06e6bb8}{new\+Varnode\+Iop}} (\mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$op)
\begin{DoxyCompactList}\small\item\em Create a \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} {\itshape annotation} \mbox{\hyperlink{classVarnode}{Varnode}}. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classVarnode}{Varnode}} $\ast$ \mbox{\hyperlink{classFuncdata_acc9f6fb3e8a36e0e1e633660fc05fdbf}{new\+Varnode\+Space}} (\mbox{\hyperlink{classAddrSpace}{Addr\+Space}} $\ast$spc)
\begin{DoxyCompactList}\small\item\em Create a constant \mbox{\hyperlink{classVarnode}{Varnode}} referring to an address space. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classVarnode}{Varnode}} $\ast$ \mbox{\hyperlink{classFuncdata_a13da637294b7cae252ffc6c9e2116da2}{new\+Varnode\+Call\+Specs}} (\mbox{\hyperlink{classFuncCallSpecs}{Func\+Call\+Specs}} $\ast$fc)
\begin{DoxyCompactList}\small\item\em Create a call specification {\itshape annotation} \mbox{\hyperlink{classVarnode}{Varnode}}. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classVarnode}{Varnode}} $\ast$ \mbox{\hyperlink{classFuncdata_a731f6fd415269577b7bb1943315b8a76}{new\+Unique}} (int4 s, \mbox{\hyperlink{classDatatype}{Datatype}} $\ast$ct=(\mbox{\hyperlink{classDatatype}{Datatype}} $\ast$) 0)
\begin{DoxyCompactList}\small\item\em Create a new {\itshape temporary} \mbox{\hyperlink{classVarnode}{Varnode}}. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classVarnode}{Varnode}} $\ast$ \mbox{\hyperlink{classFuncdata_a24e80f56ef371a0010a9e67ae8510086}{new\+Code\+Ref}} (const \mbox{\hyperlink{classAddress}{Address}} \&m)
\begin{DoxyCompactList}\small\item\em Create a code address {\itshape annotation} \mbox{\hyperlink{classVarnode}{Varnode}}. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classVarnode}{Varnode}} $\ast$ \mbox{\hyperlink{classFuncdata_a84a9880613a03f3aea65acf3dd1343d6}{set\+Input\+Varnode}} (\mbox{\hyperlink{classVarnode}{Varnode}} $\ast$vn)
\begin{DoxyCompactList}\small\item\em Mark a \mbox{\hyperlink{classVarnode}{Varnode}} as an input to the function. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classFuncdata_a35c51952540dbda3f11962b22c3064a3}{adjust\+Input\+Varnodes}} (const \mbox{\hyperlink{classAddress}{Address}} \&addr, int4 size)
\begin{DoxyCompactList}\small\item\em Adjust input Varnodes contained in the given range. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classAddress}{Address}} \mbox{\hyperlink{classFuncdata_a17e49052fa778084431a6b744cc388cb}{find\+Disjoint\+Cover}} (\mbox{\hyperlink{classVarnode}{Varnode}} $\ast$vn, int4 \&sz)
\begin{DoxyCompactList}\small\item\em Find range covering given \mbox{\hyperlink{classVarnode}{Varnode}} and any intersecting Varnodes. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classVarnode}{Varnode}} $\ast$ \mbox{\hyperlink{classFuncdata_a8fa3242779be4a766a37227deb728836}{find\+Covered\+Input}} (int4 s, const \mbox{\hyperlink{classAddress}{Address}} \&loc) const
\begin{DoxyCompactList}\small\item\em Find the first input \mbox{\hyperlink{classVarnode}{Varnode}} covered by the given range. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classVarnode}{Varnode}} $\ast$ \mbox{\hyperlink{classFuncdata_a6461d0bee74dda24aafa2caa40d0fee7}{find\+Covering\+Input}} (int4 s, const \mbox{\hyperlink{classAddress}{Address}} \&loc) const
\begin{DoxyCompactList}\small\item\em Find the input \mbox{\hyperlink{classVarnode}{Varnode}} that contains the given range. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classVarnode}{Varnode}} $\ast$ \mbox{\hyperlink{classFuncdata_a718cc133e6ade757ee532f0d704c04d4}{find\+Varnode\+Input}} (int4 s, const \mbox{\hyperlink{classAddress}{Address}} \&loc) const
\begin{DoxyCompactList}\small\item\em Find the input \mbox{\hyperlink{classVarnode}{Varnode}} with the given size and storage address. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classVarnode}{Varnode}} $\ast$ \mbox{\hyperlink{classFuncdata_acb7ae831db646e2f9d64ffb2b51fa7f1}{find\+Varnode\+Written}} (int4 s, const \mbox{\hyperlink{classAddress}{Address}} \&loc, const \mbox{\hyperlink{classAddress}{Address}} \&pc, uintm uniq=$\sim$((uintm) 0)) const
\begin{DoxyCompactList}\small\item\em Find a defined \mbox{\hyperlink{classVarnode}{Varnode}} via its storage address and its definition address. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classFuncdata_ac34a257742ad827bd278d0b35e15af74}\label{classFuncdata_ac34a257742ad827bd278d0b35e15af74}} 
Varnode\+Loc\+Set\+::const\+\_\+iterator \mbox{\hyperlink{classFuncdata_ac34a257742ad827bd278d0b35e15af74}{begin\+Loc}} (void) const
\begin{DoxyCompactList}\small\item\em Start of all Varnodes sorted by storage. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classFuncdata_a49f4e57094c47d431d81545f28172c1f}\label{classFuncdata_a49f4e57094c47d431d81545f28172c1f}} 
Varnode\+Loc\+Set\+::const\+\_\+iterator \mbox{\hyperlink{classFuncdata_a49f4e57094c47d431d81545f28172c1f}{end\+Loc}} (void) const
\begin{DoxyCompactList}\small\item\em End of all Varnodes sorted by storage. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classFuncdata_a6d8fa3ac2bdccfd83dd3eba870ef3b09}\label{classFuncdata_a6d8fa3ac2bdccfd83dd3eba870ef3b09}} 
Varnode\+Loc\+Set\+::const\+\_\+iterator \mbox{\hyperlink{classFuncdata_a6d8fa3ac2bdccfd83dd3eba870ef3b09}{begin\+Loc}} (\mbox{\hyperlink{classAddrSpace}{Addr\+Space}} $\ast$spaceid) const
\begin{DoxyCompactList}\small\item\em Start of Varnodes stored in a given address space. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classFuncdata_a23bcf948b0b6306696e595b2464c746b}\label{classFuncdata_a23bcf948b0b6306696e595b2464c746b}} 
Varnode\+Loc\+Set\+::const\+\_\+iterator \mbox{\hyperlink{classFuncdata_a23bcf948b0b6306696e595b2464c746b}{end\+Loc}} (\mbox{\hyperlink{classAddrSpace}{Addr\+Space}} $\ast$spaceid) const
\begin{DoxyCompactList}\small\item\em End of Varnodes stored in a given address space. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classFuncdata_a04bcc9eaf90591b9200db7cfd1c2fce5}\label{classFuncdata_a04bcc9eaf90591b9200db7cfd1c2fce5}} 
Varnode\+Loc\+Set\+::const\+\_\+iterator \mbox{\hyperlink{classFuncdata_a04bcc9eaf90591b9200db7cfd1c2fce5}{begin\+Loc}} (const \mbox{\hyperlink{classAddress}{Address}} \&addr) const
\begin{DoxyCompactList}\small\item\em Start of Varnodes at a storage address. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classFuncdata_a4417d6ddefad162550e3abdbe8424d76}\label{classFuncdata_a4417d6ddefad162550e3abdbe8424d76}} 
Varnode\+Loc\+Set\+::const\+\_\+iterator \mbox{\hyperlink{classFuncdata_a4417d6ddefad162550e3abdbe8424d76}{end\+Loc}} (const \mbox{\hyperlink{classAddress}{Address}} \&addr) const
\begin{DoxyCompactList}\small\item\em End of Varnodes at a storage address. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classFuncdata_ad2b7ea0975c8f7022f14158d3bb9e9d5}\label{classFuncdata_ad2b7ea0975c8f7022f14158d3bb9e9d5}} 
Varnode\+Loc\+Set\+::const\+\_\+iterator \mbox{\hyperlink{classFuncdata_ad2b7ea0975c8f7022f14158d3bb9e9d5}{begin\+Loc}} (int4 s, const \mbox{\hyperlink{classAddress}{Address}} \&addr) const
\begin{DoxyCompactList}\small\item\em Start of Varnodes with given storage. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classFuncdata_ac026cfb35c8a407c50d21837510d78f7}\label{classFuncdata_ac026cfb35c8a407c50d21837510d78f7}} 
Varnode\+Loc\+Set\+::const\+\_\+iterator \mbox{\hyperlink{classFuncdata_ac026cfb35c8a407c50d21837510d78f7}{end\+Loc}} (int4 s, const \mbox{\hyperlink{classAddress}{Address}} \&addr) const
\begin{DoxyCompactList}\small\item\em End of Varnodes with given storage. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classFuncdata_afc1213896328c86680dc05c9c5daa7c5}\label{classFuncdata_afc1213896328c86680dc05c9c5daa7c5}} 
Varnode\+Loc\+Set\+::const\+\_\+iterator \mbox{\hyperlink{classFuncdata_afc1213896328c86680dc05c9c5daa7c5}{begin\+Loc}} (int4 s, const \mbox{\hyperlink{classAddress}{Address}} \&addr, uint4 fl) const
\begin{DoxyCompactList}\small\item\em Start of Varnodes matching storage and properties. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classFuncdata_a9b418941dce53af9e8ac8dcbd453a44f}\label{classFuncdata_a9b418941dce53af9e8ac8dcbd453a44f}} 
Varnode\+Loc\+Set\+::const\+\_\+iterator \mbox{\hyperlink{classFuncdata_a9b418941dce53af9e8ac8dcbd453a44f}{end\+Loc}} (int4 s, const \mbox{\hyperlink{classAddress}{Address}} \&addr, uint4 fl) const
\begin{DoxyCompactList}\small\item\em End of Varnodes matching storage and properties. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classFuncdata_a1ad396df61c154668d1f768918b46254}\label{classFuncdata_a1ad396df61c154668d1f768918b46254}} 
Varnode\+Loc\+Set\+::const\+\_\+iterator \mbox{\hyperlink{classFuncdata_a1ad396df61c154668d1f768918b46254}{begin\+Loc}} (int4 s, const \mbox{\hyperlink{classAddress}{Address}} \&addr, const \mbox{\hyperlink{classAddress}{Address}} \&pc, uintm uniq=$\sim$((uintm) 0)) const
\begin{DoxyCompactList}\small\item\em Start of Varnodes matching storage and definition address. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classFuncdata_addfc7faf2c1793283d70d16a2313416e}\label{classFuncdata_addfc7faf2c1793283d70d16a2313416e}} 
Varnode\+Loc\+Set\+::const\+\_\+iterator \mbox{\hyperlink{classFuncdata_addfc7faf2c1793283d70d16a2313416e}{end\+Loc}} (int4 s, const \mbox{\hyperlink{classAddress}{Address}} \&addr, const \mbox{\hyperlink{classAddress}{Address}} \&pc, uintm uniq=$\sim$((uintm) 0)) const
\begin{DoxyCompactList}\small\item\em End of Varnodes matching storage and definition address. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classFuncdata_af9350996f6f24052be034b59bfd383b2}\label{classFuncdata_af9350996f6f24052be034b59bfd383b2}} 
Varnode\+Def\+Set\+::const\+\_\+iterator \mbox{\hyperlink{classFuncdata_af9350996f6f24052be034b59bfd383b2}{begin\+Def}} (void) const
\begin{DoxyCompactList}\small\item\em Start of all Varnodes sorted by definition address. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classFuncdata_ad5fba46eb4e585463bafe3461d415fd4}\label{classFuncdata_ad5fba46eb4e585463bafe3461d415fd4}} 
Varnode\+Def\+Set\+::const\+\_\+iterator \mbox{\hyperlink{classFuncdata_ad5fba46eb4e585463bafe3461d415fd4}{end\+Def}} (void) const
\begin{DoxyCompactList}\small\item\em End of all Varnodes sorted by definition address. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classFuncdata_a721c960a75b9ac5652a620b6195e33f5}\label{classFuncdata_a721c960a75b9ac5652a620b6195e33f5}} 
Varnode\+Def\+Set\+::const\+\_\+iterator \mbox{\hyperlink{classFuncdata_a721c960a75b9ac5652a620b6195e33f5}{begin\+Def}} (uint4 fl) const
\begin{DoxyCompactList}\small\item\em Start of Varnodes with a given definition property. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classFuncdata_a5fa192d156e74fef2a22c274b86f3e73}\label{classFuncdata_a5fa192d156e74fef2a22c274b86f3e73}} 
Varnode\+Def\+Set\+::const\+\_\+iterator \mbox{\hyperlink{classFuncdata_a5fa192d156e74fef2a22c274b86f3e73}{end\+Def}} (uint4 fl) const
\begin{DoxyCompactList}\small\item\em End of Varnodes with a given definition property. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classFuncdata_a52feb85441fe82ca75ec8334244d0426}\label{classFuncdata_a52feb85441fe82ca75ec8334244d0426}} 
Varnode\+Def\+Set\+::const\+\_\+iterator \mbox{\hyperlink{classFuncdata_a52feb85441fe82ca75ec8334244d0426}{begin\+Def}} (uint4 fl, const \mbox{\hyperlink{classAddress}{Address}} \&addr) const
\begin{DoxyCompactList}\small\item\em Start of (input or free) Varnodes at a given storage address. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classFuncdata_ab112eb1f47f8e32c0018c7af989f519c}\label{classFuncdata_ab112eb1f47f8e32c0018c7af989f519c}} 
Varnode\+Def\+Set\+::const\+\_\+iterator \mbox{\hyperlink{classFuncdata_ab112eb1f47f8e32c0018c7af989f519c}{end\+Def}} (uint4 fl, const \mbox{\hyperlink{classAddress}{Address}} \&addr) const
\begin{DoxyCompactList}\small\item\em End of (input or free) Varnodes at a given storage address. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classFuncdata_a483d190eec54662367b015b59e245328}{check\+For\+Laned\+Register}} (int4 size, const \mbox{\hyperlink{classAddress}{Address}} \&addr)
\begin{DoxyCompactList}\small\item\em Check for a potential laned register. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classHighVariable}{High\+Variable}} $\ast$ \mbox{\hyperlink{classFuncdata_aa34c7b2d0d5f4cb28e0a2602d3cba033}{find\+High}} (const string \&name) const
\begin{DoxyCompactList}\small\item\em Find a high-\/level variable by name. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classFuncdata_aed6aefa7321e887e3b759de94e4d3d4f}{map\+Globals}} (void)
\begin{DoxyCompactList}\small\item\em Make sure there is a \mbox{\hyperlink{classSymbol}{Symbol}} entry for all global Varnodes. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classFuncdata_add076d930ec2ceb66453451e478ca7d4}{check\+Call\+Double\+Use}} (const \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$opmatch, const \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$op, const \mbox{\hyperlink{classVarnode}{Varnode}} $\ast$vn, const \mbox{\hyperlink{classParamTrial}{Param\+Trial}} \&trial) const
\begin{DoxyCompactList}\small\item\em Test for legitimate double use of a parameter trial. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classFuncdata_a07ddc6cd232b4a101968d960fda9b965}{only\+Op\+Use}} (const \mbox{\hyperlink{classVarnode}{Varnode}} $\ast$invn, const \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$opmatch, const \mbox{\hyperlink{classParamTrial}{Param\+Trial}} \&trial) const
\begin{DoxyCompactList}\small\item\em Test if the given \mbox{\hyperlink{classVarnode}{Varnode}} seems to only be used by a C\+A\+LL. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classFuncdata_adfa02a817ac34b428cac2a327d1891c0}{ancestor\+Op\+Use}} (int4 maxlevel, const \mbox{\hyperlink{classVarnode}{Varnode}} $\ast$invn, const \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$op, \mbox{\hyperlink{classParamTrial}{Param\+Trial}} \&trial) const
\begin{DoxyCompactList}\small\item\em Test if the given trial \mbox{\hyperlink{classVarnode}{Varnode}} is likely only used for parameter passing. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classFuncdata_aca583e76acc0a61bc30bd32461d25aee}{sync\+Varnodes\+With\+Symbols}} (const \mbox{\hyperlink{classScopeLocal}{Scope\+Local}} $\ast$lm, bool typesyes)
\begin{DoxyCompactList}\small\item\em Update \mbox{\hyperlink{classVarnode}{Varnode}} properties based on (new) \mbox{\hyperlink{classSymbol}{Symbol}} information. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classFuncdata_a070edf06c2d300a7d6d1bda21189b477}{transfer\+Varnode\+Properties}} (\mbox{\hyperlink{classVarnode}{Varnode}} $\ast$vn, \mbox{\hyperlink{classVarnode}{Varnode}} $\ast$new\+Vn, int4 lsb\+Offset)
\begin{DoxyCompactList}\small\item\em Copy properties from an existing \mbox{\hyperlink{classVarnode}{Varnode}} to a new \mbox{\hyperlink{classVarnode}{Varnode}}. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classFuncdata_af47b9524aee42c71c7dbe260a4052485}{fillin\+Read\+Only}} (\mbox{\hyperlink{classVarnode}{Varnode}} $\ast$vn)
\begin{DoxyCompactList}\small\item\em Replace the given \mbox{\hyperlink{classVarnode}{Varnode}} with its (constant) value in the load image. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classFuncdata_a754fe8bd5805e6d9fd8041365e7747eb}{replace\+Volatile}} (\mbox{\hyperlink{classVarnode}{Varnode}} $\ast$vn)
\begin{DoxyCompactList}\small\item\em Replace accesses of the given \mbox{\hyperlink{classVarnode}{Varnode}} with {\itshape volatile} operations. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classFuncdata_a41dc1e061256c4cc55e7afcf5995f435}{mark\+Indirect\+Only}} (void)
\begin{DoxyCompactList}\small\item\em Mark {\itshape illegal} {\itshape input} Varnodes used only in I\+N\+D\+I\+R\+E\+C\+Ts. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classFuncdata_aab7f940f85609d395283520eca3a71f0}{total\+Replace}} (\mbox{\hyperlink{classVarnode}{Varnode}} $\ast$vn, \mbox{\hyperlink{classVarnode}{Varnode}} $\ast$newvn)
\begin{DoxyCompactList}\small\item\em Replace all read references to the first \mbox{\hyperlink{classVarnode}{Varnode}} with a second \mbox{\hyperlink{classVarnode}{Varnode}}. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classFuncdata_a2934e1e4246d41a5e28f6fcb56acc937}{total\+Replace\+Constant}} (\mbox{\hyperlink{classVarnode}{Varnode}} $\ast$vn, uintb val)
\begin{DoxyCompactList}\small\item\em Replace every read reference of the given \mbox{\hyperlink{classVarnode}{Varnode}} with a constant value. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classFuncdata_ae454fbd3566fbd43103dcabdf2681fd8}{init\+Active\+Output}} (void)
\item 
\mbox{\Hypertarget{classFuncdata_a8f29c20e2a01d0cbf600b613e929e88c}\label{classFuncdata_a8f29c20e2a01d0cbf600b613e929e88c}} 
void \mbox{\hyperlink{classFuncdata_a8f29c20e2a01d0cbf600b613e929e88c}{clear\+Active\+Output}} (void)
\begin{DoxyCompactList}\small\item\em Clear any analysis of the function\textquotesingle{}s {\itshape return} prototype. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classFuncdata_afadeeb585ee8728c427fd6914b8bb7b1}\label{classFuncdata_afadeeb585ee8728c427fd6914b8bb7b1}} 
void \mbox{\hyperlink{classFuncdata_afadeeb585ee8728c427fd6914b8bb7b1}{set\+High\+Level}} (void)
\begin{DoxyCompactList}\small\item\em Turn on \mbox{\hyperlink{classHighVariable}{High\+Variable}} objects for all Varnodes. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classFuncdata_a4096b0e76e9015f9aa61fa56cb85d79c}{clear\+Dead\+Varnodes}} (void)
\begin{DoxyCompactList}\small\item\em Delete any dead Varnodes. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classFuncdata_a5b338d2b2d1a72db73369e8631125ffd}{calc\+N\+Z\+Mask}} (void)
\begin{DoxyCompactList}\small\item\em Calculate {\itshape non-\/zero} masks for all Varnodes. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classFuncdata_a5acc07e00146316532a3806cd19815bb}{clear\+Symbol\+Links}} (\mbox{\hyperlink{classHighVariable}{High\+Variable}} $\ast$high)
\begin{DoxyCompactList}\small\item\em Clear Symbols attached to Varnodes in the given \mbox{\hyperlink{classHighVariable}{High\+Variable}}. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classFuncdata_a6145d643e13a072975e34255a06f4e84}{remap\+Varnode}} (\mbox{\hyperlink{classVarnode}{Varnode}} $\ast$vn, \mbox{\hyperlink{classSymbol}{Symbol}} $\ast$sym, const \mbox{\hyperlink{classAddress}{Address}} \&usepoint)
\begin{DoxyCompactList}\small\item\em Remap a \mbox{\hyperlink{classSymbol}{Symbol}} to a given \mbox{\hyperlink{classVarnode}{Varnode}} using a static mapping. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classFuncdata_a73cbb6375e48cddaedf5e55e40119c84}{remap\+Dynamic\+Varnode}} (\mbox{\hyperlink{classVarnode}{Varnode}} $\ast$vn, \mbox{\hyperlink{classSymbol}{Symbol}} $\ast$sym, const \mbox{\hyperlink{classAddress}{Address}} \&usepoint, uint8 hash)
\begin{DoxyCompactList}\small\item\em Remap a \mbox{\hyperlink{classSymbol}{Symbol}} to a given \mbox{\hyperlink{classVarnode}{Varnode}} using a new dynamic mapping. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classSymbol}{Symbol}} $\ast$ \mbox{\hyperlink{classFuncdata_afbb3bc5ac9e2c09eda544db34b8f5879}{link\+Symbol}} (\mbox{\hyperlink{classVarnode}{Varnode}} $\ast$vn)
\begin{DoxyCompactList}\small\item\em Find or create \mbox{\hyperlink{classSymbol}{Symbol}} associated with given \mbox{\hyperlink{classVarnode}{Varnode}}. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classSymbol}{Symbol}} $\ast$ \mbox{\hyperlink{classFuncdata_a736351e8eb6c044fe00deb0cf7e6b5c5}{link\+Symbol\+Reference}} (\mbox{\hyperlink{classVarnode}{Varnode}} $\ast$vn)
\begin{DoxyCompactList}\small\item\em Discover and attach \mbox{\hyperlink{classSymbol}{Symbol}} to a constant reference. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classVarnode}{Varnode}} $\ast$ \mbox{\hyperlink{classFuncdata_a9debba02fdd2a35a5bc5d7cd57fbcd5f}{find\+Linked\+Varnode}} (\mbox{\hyperlink{classSymbolEntry}{Symbol\+Entry}} $\ast$entry) const
\begin{DoxyCompactList}\small\item\em Find a \mbox{\hyperlink{classVarnode}{Varnode}} matching the given \mbox{\hyperlink{classSymbol}{Symbol}} mapping. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classFuncdata_a1b70ae4ce90305e74d143566a97f166f}{find\+Linked\+Varnodes}} (\mbox{\hyperlink{classSymbolEntry}{Symbol\+Entry}} $\ast$entry, vector$<$ \mbox{\hyperlink{classVarnode}{Varnode}} $\ast$ $>$ \&res) const
\begin{DoxyCompactList}\small\item\em Find Varnodes that map to the given \mbox{\hyperlink{classSymbolEntry}{Symbol\+Entry}}. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classFuncdata_aa15db3d569027578de69c065fc607c63}{build\+Dynamic\+Symbol}} (\mbox{\hyperlink{classVarnode}{Varnode}} $\ast$vn)
\begin{DoxyCompactList}\small\item\em Build a {\itshape dynamic} \mbox{\hyperlink{classSymbol}{Symbol}} associated with the given \mbox{\hyperlink{classVarnode}{Varnode}}. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classFuncdata_adeee32fc648486d26cd17ebb37bb118f}{attempt\+Dynamic\+Mapping}} (\mbox{\hyperlink{classSymbolEntry}{Symbol\+Entry}} $\ast$entry, \mbox{\hyperlink{classDynamicHash}{Dynamic\+Hash}} \&dhash)
\begin{DoxyCompactList}\small\item\em Map properties of a dynamic symbol to a \mbox{\hyperlink{classVarnode}{Varnode}}. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classFuncdata_a69dddb637a6e322632f9a4bb10c5c36e}{attempt\+Dynamic\+Mapping\+Late}} (\mbox{\hyperlink{classSymbolEntry}{Symbol\+Entry}} $\ast$entry, \mbox{\hyperlink{classDynamicHash}{Dynamic\+Hash}} \&dhash)
\begin{DoxyCompactList}\small\item\em Map the name of a dynamic symbol to a \mbox{\hyperlink{classVarnode}{Varnode}}. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$ \mbox{\hyperlink{classFuncdata_a1b1e9831bb4b1c65df6950ae1f15e0be}{new\+Op}} (int4 inputs, const \mbox{\hyperlink{classAddress}{Address}} \&pc)
\item 
\mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$ \mbox{\hyperlink{classFuncdata_a0d122aa09d739e59a5107338f8ecd8ab}{new\+Op}} (int4 inputs, const \mbox{\hyperlink{classSeqNum}{Seq\+Num}} \&sq)
\begin{DoxyCompactList}\small\item\em Allocate a new \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} with \mbox{\hyperlink{classAddress}{Address}}. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$ \mbox{\hyperlink{classFuncdata_ae1126d213d88120c9e55b5779d746859}{new\+Op\+Before}} (\mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$follow, \mbox{\hyperlink{opcodes_8hh_abeb7dfb0e9e2b3114e240a405d046ea7}{Op\+Code}} opc, \mbox{\hyperlink{classVarnode}{Varnode}} $\ast$in1, \mbox{\hyperlink{classVarnode}{Varnode}} $\ast$in2, \mbox{\hyperlink{classVarnode}{Varnode}} $\ast$in3=(\mbox{\hyperlink{classVarnode}{Varnode}} $\ast$) 0)
\begin{DoxyCompactList}\small\item\em Allocate a new \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} with sequence number. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$ \mbox{\hyperlink{classFuncdata_a1da8e9506c5b37fce86d165974a4cafb}{clone\+Op}} (const \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$op, const \mbox{\hyperlink{classSeqNum}{Seq\+Num}} \&seq)
\item 
\mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$ \mbox{\hyperlink{classFuncdata_a97f6152575b9b9cbe1c5c447a78efcd3}{get\+First\+Return\+Op}} (void) const
\begin{DoxyCompactList}\small\item\em Clone a \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} into {\bfseries{this}} function. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$ \mbox{\hyperlink{classFuncdata_a008246c0350878f3d312b174a227b676}{new\+Indirect\+Op}} (\mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$indeffect, const \mbox{\hyperlink{classAddress}{Address}} \&addr, int4 size, uint4 extra\+Flags)
\begin{DoxyCompactList}\small\item\em Find a representative C\+P\+U\+I\+\_\+\+R\+E\+T\+U\+RN op for {\bfseries{this}} function. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$ \mbox{\hyperlink{classFuncdata_add1098b768d9a176cf59e4f4c9e27cb5}{new\+Indirect\+Creation}} (\mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$indeffect, const \mbox{\hyperlink{classAddress}{Address}} \&addr, int4 size, bool possibleout)
\begin{DoxyCompactList}\small\item\em Build a C\+P\+U\+I\+\_\+\+I\+N\+D\+I\+R\+E\+CT op that {\itshape indirectly} {\itshape creates} a \mbox{\hyperlink{classVarnode}{Varnode}}. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classFuncdata_a90af6702bb2cf33ecc7dee059b6e3eb9}{mark\+Indirect\+Creation}} (\mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$indop, bool possible\+Output)
\begin{DoxyCompactList}\small\item\em Convert C\+P\+U\+I\+\_\+\+I\+N\+D\+I\+R\+E\+CT into an {\itshape indirect} {\itshape creation}. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classFuncdata_a9dd86e17a47020d06ac8dfd3bb732fe5}{op\+Insert\+Before}} (\mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$op, \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$follow)
\begin{DoxyCompactList}\small\item\em Insert given \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} before a specific op. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classFuncdata_a3320ad92e11a48a06e21b8a55395a56b}{op\+Insert\+After}} (\mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$op, \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$prev)
\begin{DoxyCompactList}\small\item\em Insert given \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} after a specific op. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classFuncdata_ae6341eb8ca8a8004f1c77a8e8147a286}{op\+Insert\+Begin}} (\mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$op, \mbox{\hyperlink{classBlockBasic}{Block\+Basic}} $\ast$bl)
\begin{DoxyCompactList}\small\item\em Insert given \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} at the beginning of a basic block. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classFuncdata_ad544a6136ff019bbd18c45043e9b6900}{op\+Insert\+End}} (\mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$op, \mbox{\hyperlink{classBlockBasic}{Block\+Basic}} $\ast$bl)
\begin{DoxyCompactList}\small\item\em Insert given \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} at the end of a basic block. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classFuncdata_a9cda5e2de1725ebf3fb885e375ea1a9d}\label{classFuncdata_a9cda5e2de1725ebf3fb885e375ea1a9d}} 
void \mbox{\hyperlink{classFuncdata_a9cda5e2de1725ebf3fb885e375ea1a9d}{op\+Dead\+Insert\+After}} (\mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$op, \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$prev)
\begin{DoxyCompactList}\small\item\em Moved given \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} to specified point in the {\itshape dead} list. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classFuncdata_ad9dbf52668db4a1923537e2128719181}{op\+Set\+Opcode}} (\mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$op, \mbox{\hyperlink{opcodes_8hh_abeb7dfb0e9e2b3114e240a405d046ea7}{Op\+Code}} opc)
\begin{DoxyCompactList}\small\item\em Set the op-\/code for a specific \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}}. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classFuncdata_acdbfab2362e4d4945c3feb7d3f2c42f2}{op\+Mark\+Halt}} (\mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$op, uint4 flag)
\begin{DoxyCompactList}\small\item\em Mark given C\+P\+U\+I\+\_\+\+R\+E\+T\+U\+RN op as a {\itshape special} halt. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classFuncdata_ab2bd3523c574c5b303728ef4d880ec3a}{op\+Set\+Output}} (\mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$op, \mbox{\hyperlink{classVarnode}{Varnode}} $\ast$vn)
\begin{DoxyCompactList}\small\item\em Set a specific output \mbox{\hyperlink{classVarnode}{Varnode}} for the given \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}}. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classFuncdata_ab91b54da6501e12d4ad1e81ab5d0e5c4}{op\+Unset\+Output}} (\mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$op)
\begin{DoxyCompactList}\small\item\em Remove output \mbox{\hyperlink{classVarnode}{Varnode}} from the given \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}}. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classFuncdata_aa079e2bd26e92671be79601535236a63}{op\+Set\+Input}} (\mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$op, \mbox{\hyperlink{classVarnode}{Varnode}} $\ast$vn, int4 slot)
\begin{DoxyCompactList}\small\item\em Set a specific input operand for the given \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}}. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classFuncdata_a1ae30fdfbe33ecfa6668b5579ae3e82a}{op\+Swap\+Input}} (\mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$op, int4 slot1, int4 slot2)
\begin{DoxyCompactList}\small\item\em Swap two input operands in the given \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}}. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classFuncdata_a16f821f09d862b3c908d2bce7530b90a}{op\+Unset\+Input}} (\mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$op, int4 slot)
\begin{DoxyCompactList}\small\item\em Clear an input operand slot for the given \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}}. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classFuncdata_a6b77ee6442d79ae754d5dcf0b5318fca}{op\+Insert}} (\mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$op, \mbox{\hyperlink{classBlockBasic}{Block\+Basic}} $\ast$bl, list$<$ \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$ $>$\+::iterator iter)
\begin{DoxyCompactList}\small\item\em Insert the given \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} at specific point in a basic block. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classFuncdata_aacf0cf87976170d62df42411ffe1e10a}{op\+Uninsert}} (\mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$op)
\begin{DoxyCompactList}\small\item\em Remove the given \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} from its basic block. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classFuncdata_a495ebac694bc98d041e29ce05eece6f9}{op\+Unlink}} (\mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$op)
\begin{DoxyCompactList}\small\item\em Unset inputs/output and remove given Pcode\+OP from its basic block. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classFuncdata_a6976625d7b40efca0bc9941cb199ee44}{op\+Destroy}} (\mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$op)
\begin{DoxyCompactList}\small\item\em Remove given \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} and destroy its \mbox{\hyperlink{classVarnode}{Varnode}} operands. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classFuncdata_aeef2a6be0e9c641f72bf4e87020ddf37}{op\+Destroy\+Raw}} (\mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$op)
\begin{DoxyCompactList}\small\item\em Remove the given {\itshape raw} \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}}. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classFuncdata_adcad3bfd56955103a031fa6d0e78acec}{op\+Set\+All\+Input}} (\mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$op, const vector$<$ \mbox{\hyperlink{classVarnode}{Varnode}} $\ast$ $>$ \&vvec)
\begin{DoxyCompactList}\small\item\em Set all input Varnodes for the given \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} simultaneously. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classFuncdata_a84937c2241ea5679280223cc0ec8b202}{op\+Remove\+Input}} (\mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$op, int4 slot)
\begin{DoxyCompactList}\small\item\em Remove a specific input slot for the given \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}}. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classFuncdata_ab34e641f5ee6f2ebf4aa708e21f2b24c}{op\+Insert\+Input}} (\mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$op, \mbox{\hyperlink{classVarnode}{Varnode}} $\ast$vn, int4 slot)
\begin{DoxyCompactList}\small\item\em Insert a new \mbox{\hyperlink{classVarnode}{Varnode}} into the operand list for the given \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}}. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classVarnode}{Varnode}} $\ast$ \mbox{\hyperlink{classFuncdata_a65e8837c811e309578d2828486bcafb5}{create\+Stack\+Ref}} (\mbox{\hyperlink{classAddrSpace}{Addr\+Space}} $\ast$spc, uintb off, \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$op, \mbox{\hyperlink{classVarnode}{Varnode}} $\ast$stackptr, bool insertafter)
\begin{DoxyCompactList}\small\item\em Create an I\+N\+T\+\_\+\+A\+DD \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} calculating an offset to the {\itshape spacebase} register. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classVarnode}{Varnode}} $\ast$ \mbox{\hyperlink{classFuncdata_a37b36505bab6f7c5676157288e65d5c6}{op\+Stack\+Load}} (\mbox{\hyperlink{classAddrSpace}{Addr\+Space}} $\ast$spc, uintb off, uint4 sz, \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$op, \mbox{\hyperlink{classVarnode}{Varnode}} $\ast$stackptr, bool insertafter)
\begin{DoxyCompactList}\small\item\em Create a L\+O\+AD expression at an offset relative to a {\itshape spacebase} register for a given address space. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$ \mbox{\hyperlink{classFuncdata_a4582ad34b4e7c851d92db8544999eaf3}{op\+Stack\+Store}} (\mbox{\hyperlink{classAddrSpace}{Addr\+Space}} $\ast$spc, uintb off, \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$op, bool insertafter)
\begin{DoxyCompactList}\small\item\em Create a S\+T\+O\+RE expression at an offset relative to a {\itshape spacebase} register for a given address space. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classFuncdata_ad74d3baa2516f448e7ab5f9a8151b572}{op\+Undo\+Ptradd}} (\mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$op, bool finalize)
\begin{DoxyCompactList}\small\item\em Convert a C\+P\+U\+I\+\_\+\+P\+T\+R\+A\+DD back into a C\+P\+U\+I\+\_\+\+I\+N\+T\+\_\+\+A\+DD. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classFuncdata_a47de4c82b4a74b356153eb8e4215f639}\label{classFuncdata_a47de4c82b4a74b356153eb8e4215f639}} 
list$<$ \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$ $>$\+::const\+\_\+iterator \mbox{\hyperlink{classFuncdata_a47de4c82b4a74b356153eb8e4215f639}{begin\+Op}} (\mbox{\hyperlink{opcodes_8hh_abeb7dfb0e9e2b3114e240a405d046ea7}{Op\+Code}} opc) const
\begin{DoxyCompactList}\small\item\em Start of \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} objects with the given op-\/code. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classFuncdata_ad24461680d41c61349b3717283d8b854}\label{classFuncdata_ad24461680d41c61349b3717283d8b854}} 
list$<$ \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$ $>$\+::const\+\_\+iterator \mbox{\hyperlink{classFuncdata_ad24461680d41c61349b3717283d8b854}{end\+Op}} (\mbox{\hyperlink{opcodes_8hh_abeb7dfb0e9e2b3114e240a405d046ea7}{Op\+Code}} opc) const
\begin{DoxyCompactList}\small\item\em End of \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} objects with the given op-\/code. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classFuncdata_ae1a4f058ff4886d7ae4ceb8160c6f3e0}\label{classFuncdata_ae1a4f058ff4886d7ae4ceb8160c6f3e0}} 
list$<$ \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$ $>$\+::const\+\_\+iterator \mbox{\hyperlink{classFuncdata_ae1a4f058ff4886d7ae4ceb8160c6f3e0}{begin\+Op\+Alive}} (void) const
\begin{DoxyCompactList}\small\item\em Start of \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} objects in the {\itshape alive} list. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classFuncdata_a01a64130db5cbaaa972eed4509933870}\label{classFuncdata_a01a64130db5cbaaa972eed4509933870}} 
list$<$ \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$ $>$\+::const\+\_\+iterator \mbox{\hyperlink{classFuncdata_a01a64130db5cbaaa972eed4509933870}{end\+Op\+Alive}} (void) const
\begin{DoxyCompactList}\small\item\em End of \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} objects in the {\itshape alive} list. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classFuncdata_a2f98b1b212ede713c3fe936bc2c7e2ea}\label{classFuncdata_a2f98b1b212ede713c3fe936bc2c7e2ea}} 
list$<$ \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$ $>$\+::const\+\_\+iterator \mbox{\hyperlink{classFuncdata_a2f98b1b212ede713c3fe936bc2c7e2ea}{begin\+Op\+Dead}} (void) const
\begin{DoxyCompactList}\small\item\em Start of \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} objects in the {\itshape dead} list. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classFuncdata_a5974d38341f528cce4878658d11b4d0f}\label{classFuncdata_a5974d38341f528cce4878658d11b4d0f}} 
list$<$ \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$ $>$\+::const\+\_\+iterator \mbox{\hyperlink{classFuncdata_a5974d38341f528cce4878658d11b4d0f}{end\+Op\+Dead}} (void) const
\begin{DoxyCompactList}\small\item\em End of \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} objects in the {\itshape dead} list. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classFuncdata_a1bbd4329856ff0c1ae80672dfbc79d83}\label{classFuncdata_a1bbd4329856ff0c1ae80672dfbc79d83}} 
Pcode\+Op\+Tree\+::const\+\_\+iterator \mbox{\hyperlink{classFuncdata_a1bbd4329856ff0c1ae80672dfbc79d83}{begin\+Op\+All}} (void) const
\begin{DoxyCompactList}\small\item\em Start of all (alive) \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} objects sorted by sequence number. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classFuncdata_a7e51e10ff92ea150cb4fe73d4fdd64dd}\label{classFuncdata_a7e51e10ff92ea150cb4fe73d4fdd64dd}} 
Pcode\+Op\+Tree\+::const\+\_\+iterator \mbox{\hyperlink{classFuncdata_a7e51e10ff92ea150cb4fe73d4fdd64dd}{end\+Op\+All}} (void) const
\begin{DoxyCompactList}\small\item\em End of all (alive) \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} objects sorted by sequence number. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classFuncdata_a07dbd8a5ef4e19cd8e8c445cf8e43282}\label{classFuncdata_a07dbd8a5ef4e19cd8e8c445cf8e43282}} 
Pcode\+Op\+Tree\+::const\+\_\+iterator \mbox{\hyperlink{classFuncdata_a07dbd8a5ef4e19cd8e8c445cf8e43282}{begin\+Op}} (const \mbox{\hyperlink{classAddress}{Address}} \&addr) const
\begin{DoxyCompactList}\small\item\em Start of all (alive) \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} objects attached to a specific \mbox{\hyperlink{classAddress}{Address}}. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classFuncdata_abd4ddbda57c4b42954ad64ddfdc0b251}\label{classFuncdata_abd4ddbda57c4b42954ad64ddfdc0b251}} 
Pcode\+Op\+Tree\+::const\+\_\+iterator \mbox{\hyperlink{classFuncdata_abd4ddbda57c4b42954ad64ddfdc0b251}{end\+Op}} (const \mbox{\hyperlink{classAddress}{Address}} \&addr) const
\begin{DoxyCompactList}\small\item\em End of all (alive) \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} objects attached to a specific \mbox{\hyperlink{classAddress}{Address}}. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classFuncdata_a63f8f05085e81b696eb3f1b4dcf398be}{move\+Respecting\+Cover}} (\mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$op, \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$last\+Op)
\begin{DoxyCompactList}\small\item\em Move given op past {\itshape last\+Op} respecting covers if possible. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classJumpTable}{Jump\+Table}} $\ast$ \mbox{\hyperlink{classFuncdata_a512f5823b1a33e9430584067d77a52c5}{link\+Jump\+Table}} (\mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$op)
\begin{DoxyCompactList}\small\item\em Link jump-\/table with a given B\+R\+A\+N\+C\+H\+I\+ND. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classJumpTable}{Jump\+Table}} $\ast$ \mbox{\hyperlink{classFuncdata_a9a314cd3b9e823c436ac47e356da8a39}{find\+Jump\+Table}} (const \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$op) const
\begin{DoxyCompactList}\small\item\em Find a jump-\/table associated with a given B\+R\+A\+N\+C\+H\+I\+ND. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classJumpTable}{Jump\+Table}} $\ast$ \mbox{\hyperlink{classFuncdata_a337a544e372368eb5c41b1bb5e410932}{install\+Jump\+Table}} (const \mbox{\hyperlink{classAddress}{Address}} \&addr)
\begin{DoxyCompactList}\small\item\em Install a new jump-\/table for the given \mbox{\hyperlink{classAddress}{Address}}. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classJumpTable}{Jump\+Table}} $\ast$ \mbox{\hyperlink{classFuncdata_a38d58c33cdc77c663fceb7de1f6aadeb}{recover\+Jump\+Table}} (\mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$op, \mbox{\hyperlink{classFlowInfo}{Flow\+Info}} $\ast$flow, int4 \&failuremode)
\begin{DoxyCompactList}\small\item\em Recover destinations for a B\+R\+A\+N\+C\+H\+I\+ND by analyzing nearby data and control-\/flow. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classFuncdata_a2e75df713649c7bba52b17b1b84bbcf6}{remove\+Jump\+Table}} (\mbox{\hyperlink{classJumpTable}{Jump\+Table}} $\ast$jt)
\begin{DoxyCompactList}\small\item\em Remove/delete the given jump-\/table. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classFuncdata_a15885a8369e2c43c8c7883a4fabd533e}{set\+Basic\+Block\+Range}} (\mbox{\hyperlink{classBlockBasic}{Block\+Basic}} $\ast$bb, const \mbox{\hyperlink{classAddress}{Address}} \&beg, const \mbox{\hyperlink{classAddress}{Address}} \&end)
\begin{DoxyCompactList}\small\item\em Set the initial ownership range for the given basic block. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classFuncdata_aa486c5f0556919686a9fdad4ebc2dcc1}{remove\+Do\+Nothing\+Block}} (\mbox{\hyperlink{classBlockBasic}{Block\+Basic}} $\ast$bb)
\begin{DoxyCompactList}\small\item\em Remove a basic block from control-\/flow that performs no operations. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classFuncdata_a0fca3088c3d01a584aef0db49dfccc63}{remove\+Unreachable\+Blocks}} (bool issuewarning, bool checkexistence)
\begin{DoxyCompactList}\small\item\em Remove any unreachable basic blocks. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classFuncdata_aa2d635570305e3ea710ade3cf090ba8c}{push\+Branch}} (\mbox{\hyperlink{classBlockBasic}{Block\+Basic}} $\ast$bb, int4 slot, \mbox{\hyperlink{classBlockBasic}{Block\+Basic}} $\ast$bbnew)
\begin{DoxyCompactList}\small\item\em Move a control-\/flow edge from one block to another. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classFuncdata_a3a53162bf9a1756c4f2f4d7d1d7bbcec}{remove\+Branch}} (\mbox{\hyperlink{classBlockBasic}{Block\+Basic}} $\ast$bb, int4 num)
\begin{DoxyCompactList}\small\item\em Remove the indicated branch from a basic block. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classBlockBasic}{Block\+Basic}} $\ast$ \mbox{\hyperlink{classFuncdata_ad810c24ce5fb16a95de1f7d27c8856d8}{node\+Join\+Create\+Block}} (\mbox{\hyperlink{classBlockBasic}{Block\+Basic}} $\ast$block1, \mbox{\hyperlink{classBlockBasic}{Block\+Basic}} $\ast$block2, \mbox{\hyperlink{classBlockBasic}{Block\+Basic}} $\ast$exita, \mbox{\hyperlink{classBlockBasic}{Block\+Basic}} $\ast$exitb, bool fora\+\_\+block1ishigh, bool forb\+\_\+block1ishigh, const \mbox{\hyperlink{classAddress}{Address}} \&addr)
\begin{DoxyCompactList}\small\item\em Create a new basic block for holding a merged C\+B\+R\+A\+N\+CH. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classFuncdata_a3e19baf8aa1db2ecde4fd12075da0694}{node\+Split}} (\mbox{\hyperlink{classBlockBasic}{Block\+Basic}} $\ast$b, int4 inedge)
\begin{DoxyCompactList}\small\item\em Split control-\/flow into a basic block, duplicating its p-\/code into a new block. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classFuncdata_ac9b35091642dc7527a537d01db5ad7e1}{force\+Goto}} (const \mbox{\hyperlink{classAddress}{Address}} \&pcop, const \mbox{\hyperlink{classAddress}{Address}} \&pcdest)
\begin{DoxyCompactList}\small\item\em Force a specific control-\/flow edge to be marked as {\itshape unstructured}. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classFuncdata_af83619924b5d0fed25d0563b0f243262}{remove\+From\+Flow\+Split}} (\mbox{\hyperlink{classBlockBasic}{Block\+Basic}} $\ast$bl, bool swap)
\begin{DoxyCompactList}\small\item\em Remove a basic block splitting its control-\/flow into two distinct paths. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classFuncdata_a5ba1555023c49006ed39936b9a40aba4}{switch\+Edge}} (\mbox{\hyperlink{classFlowBlock}{Flow\+Block}} $\ast$inblock, \mbox{\hyperlink{classBlockBasic}{Block\+Basic}} $\ast$outbefore, \mbox{\hyperlink{classFlowBlock}{Flow\+Block}} $\ast$outafter)
\begin{DoxyCompactList}\small\item\em Switch an outgoing edge from the given {\itshape source} block to flow into another block. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classFuncdata_a9f0c9d7c7fb4217731ae45f7848e4034}{splice\+Block\+Basic}} (\mbox{\hyperlink{classBlockBasic}{Block\+Basic}} $\ast$bl)
\begin{DoxyCompactList}\small\item\em \mbox{\hyperlink{classMerge}{Merge}} the given basic block with the block it flows into. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classFuncdata_a9021f01b57f8704db66341bc7f65f39f}\label{classFuncdata_a9021f01b57f8704db66341bc7f65f39f}} 
void \mbox{\hyperlink{classFuncdata_a9021f01b57f8704db66341bc7f65f39f}{install\+Switch\+Defaults}} (void)
\begin{DoxyCompactList}\small\item\em Make sure default switch cases are properly labeled. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classFuncdata_a223a70ddb5e33f446fca85bc3b369911}{replace\+Lessequal}} (\mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$op)
\begin{DoxyCompactList}\small\item\em Replace I\+N\+T\+\_\+\+L\+E\+S\+S\+E\+Q\+U\+AL and I\+N\+T\+\_\+\+S\+L\+E\+S\+S\+E\+Q\+U\+AL expressions. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classFuncdata_a1b94fb7b2f8e72df053f4d09d48cdf7b}{distribute\+Int\+Mult\+Add}} (\mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$op)
\begin{DoxyCompactList}\small\item\em Distribute constant coefficient to additive input. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classFuncdata_a5027da6d3c7a05a262e332b0c22c7c43}{collapse\+Int\+Mult\+Mult}} (\mbox{\hyperlink{classVarnode}{Varnode}} $\ast$vn)
\begin{DoxyCompactList}\small\item\em Collapse constant coefficients for two chained C\+P\+U\+I\+\_\+\+I\+N\+T\+\_\+\+M\+U\+LT. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static bool \mbox{\hyperlink{classFuncdata_a4456bfc523a4527c9fd924ecadacec63}{compare\+Callspecs}} (const \mbox{\hyperlink{classFuncCallSpecs}{Func\+Call\+Specs}} $\ast$a, const \mbox{\hyperlink{classFuncCallSpecs}{Func\+Call\+Specs}} $\ast$b)
\begin{DoxyCompactList}\small\item\em Compare call specification objects by call site address. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Container for data structures associated with a single function. 

This class holds the primary data structures for decompiling a function. In particular it holds control-\/flow, data-\/flow, and prototype information, plus class instances to help with constructing S\+SA form, structure control-\/flow, recover jump-\/tables, recover parameters, and merge Varnodes. In most cases it acts as the main A\+PI for querying and accessing these structures.

Some important groups of public methods include\+:
\begin{DoxyItemize}
\item \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} manipulation (mostly starting with \textquotesingle{}op\textquotesingle{})
\item \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} search and traversal (\textquotesingle{}begin\+Op$\ast$\textquotesingle{} and \textquotesingle{}end\+Op$\ast$\textquotesingle{})
\item \mbox{\hyperlink{classVarnode}{Varnode}} creation (\textquotesingle{}new$\ast$\textquotesingle{} methods)
\item \mbox{\hyperlink{classVarnode}{Varnode}} search and traversal (\textquotesingle{}begin\+Loc\textquotesingle{} \textquotesingle{}end\+Loc\textquotesingle{} \textquotesingle{}begin\+Def\textquotesingle{} and \textquotesingle{}end\+Def\textquotesingle{})
\item Basic block access and block structuring
\item Access to subfunction prototypes
\item Access to jump-\/tables (within the body of the function) 
\end{DoxyItemize}

\doxysubsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classFuncdata_a979faf589906b1a1937623f7a2a186f2}\label{classFuncdata_a979faf589906b1a1937623f7a2a186f2}} 
\index{Funcdata@{Funcdata}!Funcdata@{Funcdata}}
\index{Funcdata@{Funcdata}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{Funcdata()}{Funcdata()}}
{\footnotesize\ttfamily Funcdata\+::\+Funcdata (\begin{DoxyParamCaption}\item[{const string \&}]{nm,  }\item[{\mbox{\hyperlink{classScope}{Scope}} $\ast$}]{scope,  }\item[{const \mbox{\hyperlink{classAddress}{Address}} \&}]{addr,  }\item[{\mbox{\hyperlink{classFunctionSymbol}{Function\+Symbol}} $\ast$}]{sym,  }\item[{int4}]{sz = {\ttfamily 0} }\end{DoxyParamCaption})}



\mbox{\hyperlink{classConstructor}{Constructor}}. 


\begin{DoxyParams}{Parameters}
{\em nm} & is the (base) name of the function \\
\hline
{\em scope} & is \mbox{\hyperlink{classSymbol}{Symbol}} scope associated with the function \\
\hline
{\em addr} & is the entry address for the function \\
\hline
{\em sym} & is the symbol representing the function \\
\hline
{\em sz} & is the number of bytes (of code) in the function body \\
\hline
\end{DoxyParams}


\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{classFuncdata_a35c51952540dbda3f11962b22c3064a3}\label{classFuncdata_a35c51952540dbda3f11962b22c3064a3}} 
\index{Funcdata@{Funcdata}!adjustInputVarnodes@{adjustInputVarnodes}}
\index{adjustInputVarnodes@{adjustInputVarnodes}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{adjustInputVarnodes()}{adjustInputVarnodes()}}
{\footnotesize\ttfamily void Funcdata\+::adjust\+Input\+Varnodes (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classAddress}{Address}} \&}]{addr,  }\item[{int4}]{size }\end{DoxyParamCaption})}



Adjust input Varnodes contained in the given range. 

After this call, a single {\itshape input} \mbox{\hyperlink{classVarnode}{Varnode}} will exist that fills the given range. Any previous input Varnodes contained in this range are redefined using a S\+U\+B\+P\+I\+E\+CE op off of the new single input. If an overlapping \mbox{\hyperlink{classVarnode}{Varnode}} isn\textquotesingle{}t fully contained an exception is thrown. 
\begin{DoxyParams}{Parameters}
{\em addr} & is the starting address of the range \\
\hline
{\em size} & is the number of bytes in the range \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classFuncdata_adfa02a817ac34b428cac2a327d1891c0}\label{classFuncdata_adfa02a817ac34b428cac2a327d1891c0}} 
\index{Funcdata@{Funcdata}!ancestorOpUse@{ancestorOpUse}}
\index{ancestorOpUse@{ancestorOpUse}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{ancestorOpUse()}{ancestorOpUse()}}
{\footnotesize\ttfamily bool Funcdata\+::ancestor\+Op\+Use (\begin{DoxyParamCaption}\item[{int4}]{maxlevel,  }\item[{const \mbox{\hyperlink{classVarnode}{Varnode}} $\ast$}]{invn,  }\item[{const \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$}]{op,  }\item[{\mbox{\hyperlink{classParamTrial}{Param\+Trial}} \&}]{trial }\end{DoxyParamCaption}) const}



Test if the given trial \mbox{\hyperlink{classVarnode}{Varnode}} is likely only used for parameter passing. 

Flow is followed from the \mbox{\hyperlink{classVarnode}{Varnode}} itself and from ancestors the \mbox{\hyperlink{classVarnode}{Varnode}} was copied from to see if it hits anything other than the given C\+A\+LL or R\+E\+T\+U\+RN operation. 
\begin{DoxyParams}{Parameters}
{\em maxlevel} & is the maximum number of times to recurse through ancestor copies \\
\hline
{\em invn} & is the given trial \mbox{\hyperlink{classVarnode}{Varnode}} to test \\
\hline
{\em op} & is the given C\+A\+LL or R\+E\+T\+U\+RN \\
\hline
{\em trial} & is the associated parameter trial object \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\bfseries{true}} if the \mbox{\hyperlink{classVarnode}{Varnode}} is only used for the C\+A\+L\+L/\+R\+E\+T\+U\+RN 
\end{DoxyReturn}
\mbox{\Hypertarget{classFuncdata_adeee32fc648486d26cd17ebb37bb118f}\label{classFuncdata_adeee32fc648486d26cd17ebb37bb118f}} 
\index{Funcdata@{Funcdata}!attemptDynamicMapping@{attemptDynamicMapping}}
\index{attemptDynamicMapping@{attemptDynamicMapping}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{attemptDynamicMapping()}{attemptDynamicMapping()}}
{\footnotesize\ttfamily bool Funcdata\+::attempt\+Dynamic\+Mapping (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classSymbolEntry}{Symbol\+Entry}} $\ast$}]{entry,  }\item[{\mbox{\hyperlink{classDynamicHash}{Dynamic\+Hash}} \&}]{dhash }\end{DoxyParamCaption})}



Map properties of a dynamic symbol to a \mbox{\hyperlink{classVarnode}{Varnode}}. 

Given a dynamic mapping, try to find the mapped \mbox{\hyperlink{classVarnode}{Varnode}}, then adjust (type and flags) to reflect this mapping. 
\begin{DoxyParams}{Parameters}
{\em entry} & is the (dynamic) \mbox{\hyperlink{classSymbol}{Symbol}} entry \\
\hline
{\em dhash} & is the dynamic mapping information \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\bfseries{true}} if a \mbox{\hyperlink{classVarnode}{Varnode}} was adjusted 
\end{DoxyReturn}
\mbox{\Hypertarget{classFuncdata_a69dddb637a6e322632f9a4bb10c5c36e}\label{classFuncdata_a69dddb637a6e322632f9a4bb10c5c36e}} 
\index{Funcdata@{Funcdata}!attemptDynamicMappingLate@{attemptDynamicMappingLate}}
\index{attemptDynamicMappingLate@{attemptDynamicMappingLate}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{attemptDynamicMappingLate()}{attemptDynamicMappingLate()}}
{\footnotesize\ttfamily bool Funcdata\+::attempt\+Dynamic\+Mapping\+Late (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classSymbolEntry}{Symbol\+Entry}} $\ast$}]{entry,  }\item[{\mbox{\hyperlink{classDynamicHash}{Dynamic\+Hash}} \&}]{dhash }\end{DoxyParamCaption})}



Map the name of a dynamic symbol to a \mbox{\hyperlink{classVarnode}{Varnode}}. 

Given a dynamic mapping, try to find the mapped \mbox{\hyperlink{classVarnode}{Varnode}}, then attach the \mbox{\hyperlink{classSymbol}{Symbol}} to the \mbox{\hyperlink{classVarnode}{Varnode}}. The name of the \mbox{\hyperlink{classSymbol}{Symbol}} is used, but the data-\/type and possibly other properties are not put on the \mbox{\hyperlink{classVarnode}{Varnode}}. 
\begin{DoxyParams}{Parameters}
{\em entry} & is the (dynamic) \mbox{\hyperlink{classSymbol}{Symbol}} entry \\
\hline
{\em dhash} & is the dynamic mapping information \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\bfseries{true}} if a \mbox{\hyperlink{classVarnode}{Varnode}} was adjusted 
\end{DoxyReturn}
\mbox{\Hypertarget{classFuncdata_aa15db3d569027578de69c065fc607c63}\label{classFuncdata_aa15db3d569027578de69c065fc607c63}} 
\index{Funcdata@{Funcdata}!buildDynamicSymbol@{buildDynamicSymbol}}
\index{buildDynamicSymbol@{buildDynamicSymbol}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{buildDynamicSymbol()}{buildDynamicSymbol()}}
{\footnotesize\ttfamily void Funcdata\+::build\+Dynamic\+Symbol (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classVarnode}{Varnode}} $\ast$}]{vn }\end{DoxyParamCaption})}



Build a {\itshape dynamic} \mbox{\hyperlink{classSymbol}{Symbol}} associated with the given \mbox{\hyperlink{classVarnode}{Varnode}}. 

If a \mbox{\hyperlink{classSymbol}{Symbol}} is already attached, no change is made. Otherwise a special {\itshape dynamic} \mbox{\hyperlink{classSymbol}{Symbol}} is created that is associated with the \mbox{\hyperlink{classVarnode}{Varnode}} via a hash of its local data-\/flow (rather than its storage address). 
\begin{DoxyParams}{Parameters}
{\em vn} & is the given \mbox{\hyperlink{classVarnode}{Varnode}} \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classFuncdata_a5b338d2b2d1a72db73369e8631125ffd}\label{classFuncdata_a5b338d2b2d1a72db73369e8631125ffd}} 
\index{Funcdata@{Funcdata}!calcNZMask@{calcNZMask}}
\index{calcNZMask@{calcNZMask}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{calcNZMask()}{calcNZMask()}}
{\footnotesize\ttfamily void Funcdata\+::calc\+N\+Z\+Mask (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Calculate {\itshape non-\/zero} masks for all Varnodes. 

All Varnodes are initialized assuming that all its bits are possibly non-\/zero. This method looks for situations where a p-\/code produces a value that is known to have some bits that are guaranteed to be zero. It updates the state of the output \mbox{\hyperlink{classVarnode}{Varnode}} then tries to push the information forward through the data-\/flow until additional changes are apparent. \mbox{\Hypertarget{classFuncdata_add076d930ec2ceb66453451e478ca7d4}\label{classFuncdata_add076d930ec2ceb66453451e478ca7d4}} 
\index{Funcdata@{Funcdata}!checkCallDoubleUse@{checkCallDoubleUse}}
\index{checkCallDoubleUse@{checkCallDoubleUse}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{checkCallDoubleUse()}{checkCallDoubleUse()}}
{\footnotesize\ttfamily bool Funcdata\+::check\+Call\+Double\+Use (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$}]{opmatch,  }\item[{const \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$}]{op,  }\item[{const \mbox{\hyperlink{classVarnode}{Varnode}} $\ast$}]{vn,  }\item[{const \mbox{\hyperlink{classParamTrial}{Param\+Trial}} \&}]{trial }\end{DoxyParamCaption}) const}



Test for legitimate double use of a parameter trial. 

The given trial is a {\itshape putative} input to first C\+A\+LL, but can also trace its data-\/flow into a second C\+A\+LL. Return {\bfseries{false}} if this leads us to conclude that the trial is not a likely parameter. 
\begin{DoxyParams}{Parameters}
{\em opmatch} & is the first C\+A\+LL linked to the trial \\
\hline
{\em op} & is the second C\+A\+LL \\
\hline
{\em vn} & is the \mbox{\hyperlink{classVarnode}{Varnode}} parameter for the second C\+A\+LL \\
\hline
{\em trial} & is the given parameter trial \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\bfseries{true}} for a legitimate double use 
\end{DoxyReturn}
\mbox{\Hypertarget{classFuncdata_a483d190eec54662367b015b59e245328}\label{classFuncdata_a483d190eec54662367b015b59e245328}} 
\index{Funcdata@{Funcdata}!checkForLanedRegister@{checkForLanedRegister}}
\index{checkForLanedRegister@{checkForLanedRegister}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{checkForLanedRegister()}{checkForLanedRegister()}}
{\footnotesize\ttfamily void Funcdata\+::check\+For\+Laned\+Register (\begin{DoxyParamCaption}\item[{int4}]{size,  }\item[{const \mbox{\hyperlink{classAddress}{Address}} \&}]{addr }\end{DoxyParamCaption})}



Check for a potential laned register. 

Check if the given storage range is a potential laned register. If so, record the storage with the matching laned register record. 
\begin{DoxyParams}{Parameters}
{\em size} & is the size of the storage range in bytes \\
\hline
{\em addr} & is the starting address of the storage range \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classFuncdata_a4096b0e76e9015f9aa61fa56cb85d79c}\label{classFuncdata_a4096b0e76e9015f9aa61fa56cb85d79c}} 
\index{Funcdata@{Funcdata}!clearDeadVarnodes@{clearDeadVarnodes}}
\index{clearDeadVarnodes@{clearDeadVarnodes}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{clearDeadVarnodes()}{clearDeadVarnodes()}}
{\footnotesize\ttfamily void Funcdata\+::clear\+Dead\+Varnodes (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Delete any dead Varnodes. 

Free any Varnodes not attached to anything. This is only performed at fixed times so that editing operations can detach (and then reattach) Varnodes without losing them. \mbox{\Hypertarget{classFuncdata_a5acc07e00146316532a3806cd19815bb}\label{classFuncdata_a5acc07e00146316532a3806cd19815bb}} 
\index{Funcdata@{Funcdata}!clearSymbolLinks@{clearSymbolLinks}}
\index{clearSymbolLinks@{clearSymbolLinks}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{clearSymbolLinks()}{clearSymbolLinks()}}
{\footnotesize\ttfamily void Funcdata\+::clear\+Symbol\+Links (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classHighVariable}{High\+Variable}} $\ast$}]{high }\end{DoxyParamCaption})}



Clear Symbols attached to Varnodes in the given \mbox{\hyperlink{classHighVariable}{High\+Variable}}. 

For each instance \mbox{\hyperlink{classVarnode}{Varnode}}, remove any \mbox{\hyperlink{classSymbolEntry}{Symbol\+Entry}} reference and associated properties. 
\begin{DoxyParams}{Parameters}
{\em high} & is the given \mbox{\hyperlink{classHighVariable}{High\+Variable}} to clear \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classFuncdata_a1da8e9506c5b37fce86d165974a4cafb}\label{classFuncdata_a1da8e9506c5b37fce86d165974a4cafb}} 
\index{Funcdata@{Funcdata}!cloneOp@{cloneOp}}
\index{cloneOp@{cloneOp}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{cloneOp()}{cloneOp()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$ Funcdata\+::clone\+Op (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$}]{op,  }\item[{const \mbox{\hyperlink{classSeqNum}{Seq\+Num}} \&}]{seq }\end{DoxyParamCaption})}

Make a clone of the given \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}}, copying control-\/flow properties as well. The data-\/type is {\itshape not} cloned. 
\begin{DoxyParams}{Parameters}
{\em op} & is the \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} to clone \\
\hline
{\em seq} & is the (possibly custom) sequence number to associate with the clone \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the cloned \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} 
\end{DoxyReturn}
\mbox{\Hypertarget{classFuncdata_a5027da6d3c7a05a262e332b0c22c7c43}\label{classFuncdata_a5027da6d3c7a05a262e332b0c22c7c43}} 
\index{Funcdata@{Funcdata}!collapseIntMultMult@{collapseIntMultMult}}
\index{collapseIntMultMult@{collapseIntMultMult}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{collapseIntMultMult()}{collapseIntMultMult()}}
{\footnotesize\ttfamily bool Funcdata\+::collapse\+Int\+Mult\+Mult (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classVarnode}{Varnode}} $\ast$}]{vn }\end{DoxyParamCaption})}



Collapse constant coefficients for two chained C\+P\+U\+I\+\_\+\+I\+N\+T\+\_\+\+M\+U\+LT. 

If\+:
\begin{DoxyItemize}
\item The given \mbox{\hyperlink{classVarnode}{Varnode}} is defined by a C\+P\+U\+I\+\_\+\+I\+N\+T\+\_\+\+M\+U\+LT.
\item The second input to the I\+N\+T\+\_\+\+M\+U\+LT is a constant.
\item The first input is defined by another C\+P\+U\+I\+\_\+\+I\+N\+T\+\_\+\+M\+U\+LT,
\item This multiply is also by a constant.
\end{DoxyItemize}

The constants are combined and {\bfseries{true}} is returned. Otherwise no change is made and {\bfseries{false}} is returned. 
\begin{DoxyParams}{Parameters}
{\em vn} & is the given \mbox{\hyperlink{classVarnode}{Varnode}} \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\bfseries{true}} if a change was made 
\end{DoxyReturn}
\mbox{\Hypertarget{classFuncdata_a4456bfc523a4527c9fd924ecadacec63}\label{classFuncdata_a4456bfc523a4527c9fd924ecadacec63}} 
\index{Funcdata@{Funcdata}!compareCallspecs@{compareCallspecs}}
\index{compareCallspecs@{compareCallspecs}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{compareCallspecs()}{compareCallspecs()}}
{\footnotesize\ttfamily bool Funcdata\+::compare\+Callspecs (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classFuncCallSpecs}{Func\+Call\+Specs}} $\ast$}]{a,  }\item[{const \mbox{\hyperlink{classFuncCallSpecs}{Func\+Call\+Specs}} $\ast$}]{b }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Compare call specification objects by call site address. 


\begin{DoxyParams}{Parameters}
{\em a} & is the first call specification to compare \\
\hline
{\em b} & is the second call specification \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\bfseries{true}} if the first call specification should come before the second 
\end{DoxyReturn}
\mbox{\Hypertarget{classFuncdata_a65e8837c811e309578d2828486bcafb5}\label{classFuncdata_a65e8837c811e309578d2828486bcafb5}} 
\index{Funcdata@{Funcdata}!createStackRef@{createStackRef}}
\index{createStackRef@{createStackRef}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{createStackRef()}{createStackRef()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classVarnode}{Varnode}} $\ast$ Funcdata\+::create\+Stack\+Ref (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classAddrSpace}{Addr\+Space}} $\ast$}]{spc,  }\item[{uintb}]{off,  }\item[{\mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$}]{op,  }\item[{\mbox{\hyperlink{classVarnode}{Varnode}} $\ast$}]{stackptr,  }\item[{bool}]{insertafter }\end{DoxyParamCaption})}



Create an I\+N\+T\+\_\+\+A\+DD \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} calculating an offset to the {\itshape spacebase} register. 

The {\itshape spacebase} register is looked up for the given address space, or an optional previously existing register \mbox{\hyperlink{classVarnode}{Varnode}} can be provided. An insertion point op must be provided, and newly generated ops can come either before or after this insertion point. 
\begin{DoxyParams}{Parameters}
{\em spc} & is the given address space \\
\hline
{\em off} & is the offset to calculate relative to the {\itshape spacebase} register \\
\hline
{\em op} & is the insertion point \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} \\
\hline
{\em stackptr} & is the {\itshape spacebase} register \mbox{\hyperlink{classVarnode}{Varnode}} (if available) \\
\hline
{\em insertafter} & is {\bfseries{true}} if new ops are inserted {\itshape after} the insertion point \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the {\itshape unique} space \mbox{\hyperlink{classVarnode}{Varnode}} holding the calculated offset 
\end{DoxyReturn}
\mbox{\Hypertarget{classFuncdata_adaf432bbbd299e976c8f02fc97fb3dbe}\label{classFuncdata_adaf432bbbd299e976c8f02fc97fb3dbe}} 
\index{Funcdata@{Funcdata}!deadRemovalAllowed@{deadRemovalAllowed}}
\index{deadRemovalAllowed@{deadRemovalAllowed}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{deadRemovalAllowed()}{deadRemovalAllowed()}}
{\footnotesize\ttfamily bool Funcdata\+::dead\+Removal\+Allowed (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classAddrSpace}{Addr\+Space}} $\ast$}]{spc }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Check if dead code removal is allowed for a specific address space. 


\begin{DoxyParams}{Parameters}
{\em spc} & is the specific address space \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\bfseries{true}} if dead code removal is allowed 
\end{DoxyReturn}
\mbox{\Hypertarget{classFuncdata_adba7696040378f0eaa679e684b72bf96}\label{classFuncdata_adba7696040378f0eaa679e684b72bf96}} 
\index{Funcdata@{Funcdata}!deadRemovalAllowedSeen@{deadRemovalAllowedSeen}}
\index{deadRemovalAllowedSeen@{deadRemovalAllowedSeen}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{deadRemovalAllowedSeen()}{deadRemovalAllowedSeen()}}
{\footnotesize\ttfamily bool Funcdata\+::dead\+Removal\+Allowed\+Seen (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classAddrSpace}{Addr\+Space}} $\ast$}]{spc }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Check if dead Varnodes have been removed for a specific address space. 


\begin{DoxyParams}{Parameters}
{\em spc} & is the specific address space \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\bfseries{true}} if dead code removal has happened in the space 
\end{DoxyReturn}
\mbox{\Hypertarget{classFuncdata_a1b94fb7b2f8e72df053f4d09d48cdf7b}\label{classFuncdata_a1b94fb7b2f8e72df053f4d09d48cdf7b}} 
\index{Funcdata@{Funcdata}!distributeIntMultAdd@{distributeIntMultAdd}}
\index{distributeIntMultAdd@{distributeIntMultAdd}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{distributeIntMultAdd()}{distributeIntMultAdd()}}
{\footnotesize\ttfamily bool Funcdata\+::distribute\+Int\+Mult\+Add (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$}]{op }\end{DoxyParamCaption})}



Distribute constant coefficient to additive input. 

If a term has a multiplicative coefficient, but the underlying term is still additive, in some situations we may need to distribute the coefficient before simplifying further. The given \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} is a I\+N\+T\+\_\+\+M\+U\+LT where the second input is a constant. We also know the first input is formed with I\+N\+T\+\_\+\+A\+DD. Distribute the coefficient to the I\+N\+T\+\_\+\+A\+DD inputs. 
\begin{DoxyParams}{Parameters}
{\em op} & is the given \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\bfseries{true}} if the action was performed 
\end{DoxyReturn}
\mbox{\Hypertarget{classFuncdata_adb1dd79d78141f89d374e570de21d690}\label{classFuncdata_adb1dd79d78141f89d374e570de21d690}} 
\index{Funcdata@{Funcdata}!doLiveInject@{doLiveInject}}
\index{doLiveInject@{doLiveInject}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{doLiveInject()}{doLiveInject()}}
{\footnotesize\ttfamily void Funcdata\+::do\+Live\+Inject (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classInjectPayload}{Inject\+Payload}} $\ast$}]{payload,  }\item[{const \mbox{\hyperlink{classAddress}{Address}} \&}]{addr,  }\item[{\mbox{\hyperlink{classBlockBasic}{Block\+Basic}} $\ast$}]{bl,  }\item[{list$<$ \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$ $>$\+::iterator}]{iter }\end{DoxyParamCaption})}



Inject p-\/code from a {\itshape payload} into {\bfseries{this}} live function. 

Raw Pcode\+Ops are generated from the payload within a given basic block at a specific position in {\bfseries{this}} function. 
\begin{DoxyParams}{Parameters}
{\em payload} & is the injection payload \\
\hline
{\em addr} & is the address at the point of injection \\
\hline
{\em bl} & is the given basic block holding the new ops \\
\hline
{\em iter} & indicates the point of insertion \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classFuncdata_a142938fffbfd5add2b6679a6b9b0d7fa}\label{classFuncdata_a142938fffbfd5add2b6679a6b9b0d7fa}} 
\index{Funcdata@{Funcdata}!fillinExtrapop@{fillinExtrapop}}
\index{fillinExtrapop@{fillinExtrapop}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{fillinExtrapop()}{fillinExtrapop()}}
{\footnotesize\ttfamily int4 Funcdata\+::fillin\+Extrapop (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Recover and return the {\itshape extrapop} for this function. 

If {\itshape extrapop} is unknown, recover it from what we know about this function and set the value permanently for {\bfseries{this}} \mbox{\hyperlink{classFuncdata}{Funcdata}} object. If there is no function body it may be impossible to know the value, in which case this returns the reserved value indicating {\itshape extrapop} is unknown.

\begin{DoxyReturn}{Returns}
the recovered value 
\end{DoxyReturn}
\mbox{\Hypertarget{classFuncdata_af47b9524aee42c71c7dbe260a4052485}\label{classFuncdata_af47b9524aee42c71c7dbe260a4052485}} 
\index{Funcdata@{Funcdata}!fillinReadOnly@{fillinReadOnly}}
\index{fillinReadOnly@{fillinReadOnly}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{fillinReadOnly()}{fillinReadOnly()}}
{\footnotesize\ttfamily bool Funcdata\+::fillin\+Read\+Only (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classVarnode}{Varnode}} $\ast$}]{vn }\end{DoxyParamCaption})}



Replace the given \mbox{\hyperlink{classVarnode}{Varnode}} with its (constant) value in the load image. 

Treat the given \mbox{\hyperlink{classVarnode}{Varnode}} as read-\/only, look up its value in \mbox{\hyperlink{classLoadImage}{Load\+Image}} and replace read references with the value as a constant \mbox{\hyperlink{classVarnode}{Varnode}}. 
\begin{DoxyParams}{Parameters}
{\em vn} & is the given \mbox{\hyperlink{classVarnode}{Varnode}} \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\bfseries{true}} if any change was made 
\end{DoxyReturn}
\mbox{\Hypertarget{classFuncdata_a8fa3242779be4a766a37227deb728836}\label{classFuncdata_a8fa3242779be4a766a37227deb728836}} 
\index{Funcdata@{Funcdata}!findCoveredInput@{findCoveredInput}}
\index{findCoveredInput@{findCoveredInput}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{findCoveredInput()}{findCoveredInput()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classVarnode}{Varnode}}$\ast$ Funcdata\+::find\+Covered\+Input (\begin{DoxyParamCaption}\item[{int4}]{s,  }\item[{const \mbox{\hyperlink{classAddress}{Address}} \&}]{loc }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Find the first input \mbox{\hyperlink{classVarnode}{Varnode}} covered by the given range. 


\begin{DoxyParams}{Parameters}
{\em s} & is the size of the range in bytes \\
\hline
{\em loc} & is the starting address of the range \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the matching \mbox{\hyperlink{classVarnode}{Varnode}} or N\+U\+LL 
\end{DoxyReturn}
\mbox{\Hypertarget{classFuncdata_a6461d0bee74dda24aafa2caa40d0fee7}\label{classFuncdata_a6461d0bee74dda24aafa2caa40d0fee7}} 
\index{Funcdata@{Funcdata}!findCoveringInput@{findCoveringInput}}
\index{findCoveringInput@{findCoveringInput}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{findCoveringInput()}{findCoveringInput()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classVarnode}{Varnode}}$\ast$ Funcdata\+::find\+Covering\+Input (\begin{DoxyParamCaption}\item[{int4}]{s,  }\item[{const \mbox{\hyperlink{classAddress}{Address}} \&}]{loc }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Find the input \mbox{\hyperlink{classVarnode}{Varnode}} that contains the given range. 


\begin{DoxyParams}{Parameters}
{\em s} & is the size of the range in bytes \\
\hline
{\em loc} & is the starting address of the range \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the matching \mbox{\hyperlink{classVarnode}{Varnode}} or N\+U\+LL 
\end{DoxyReturn}
\mbox{\Hypertarget{classFuncdata_a17e49052fa778084431a6b744cc388cb}\label{classFuncdata_a17e49052fa778084431a6b744cc388cb}} 
\index{Funcdata@{Funcdata}!findDisjointCover@{findDisjointCover}}
\index{findDisjointCover@{findDisjointCover}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{findDisjointCover()}{findDisjointCover()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classAddress}{Address}} Funcdata\+::find\+Disjoint\+Cover (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classVarnode}{Varnode}} $\ast$}]{vn,  }\item[{int4 \&}]{sz }\end{DoxyParamCaption})}



Find range covering given \mbox{\hyperlink{classVarnode}{Varnode}} and any intersecting Varnodes. 

Find the minimal \mbox{\hyperlink{classAddress}{Address}} range covering the given \mbox{\hyperlink{classVarnode}{Varnode}} that doesn\textquotesingle{}t split other Varnodes 
\begin{DoxyParams}{Parameters}
{\em vn} & is the given \mbox{\hyperlink{classVarnode}{Varnode}} \\
\hline
{\em sz} & is used to pass back the size of the resulting range \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the starting address of the resulting range 
\end{DoxyReturn}
\mbox{\Hypertarget{classFuncdata_aa34c7b2d0d5f4cb28e0a2602d3cba033}\label{classFuncdata_aa34c7b2d0d5f4cb28e0a2602d3cba033}} 
\index{Funcdata@{Funcdata}!findHigh@{findHigh}}
\index{findHigh@{findHigh}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{findHigh()}{findHigh()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classHighVariable}{High\+Variable}} $\ast$ Funcdata\+::find\+High (\begin{DoxyParamCaption}\item[{const string \&}]{name }\end{DoxyParamCaption}) const}



Find a high-\/level variable by name. 

Look up the \mbox{\hyperlink{classSymbol}{Symbol}} visible in {\bfseries{this}} function\textquotesingle{}s \mbox{\hyperlink{classScope}{Scope}} and return the \mbox{\hyperlink{classHighVariable}{High\+Variable}} associated with it. If the \mbox{\hyperlink{classSymbol}{Symbol}} doesn\textquotesingle{}t exist or there is no \mbox{\hyperlink{classVarnode}{Varnode}} holding at least part of the value of the \mbox{\hyperlink{classSymbol}{Symbol}}, N\+U\+LL is returned. 
\begin{DoxyParams}{Parameters}
{\em name} & is the name to search for \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the matching \mbox{\hyperlink{classHighVariable}{High\+Variable}} or N\+U\+LL 
\end{DoxyReturn}
\mbox{\Hypertarget{classFuncdata_a9a314cd3b9e823c436ac47e356da8a39}\label{classFuncdata_a9a314cd3b9e823c436ac47e356da8a39}} 
\index{Funcdata@{Funcdata}!findJumpTable@{findJumpTable}}
\index{findJumpTable@{findJumpTable}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{findJumpTable()}{findJumpTable()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classJumpTable}{Jump\+Table}} $\ast$ Funcdata\+::find\+Jump\+Table (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$}]{op }\end{DoxyParamCaption}) const}



Find a jump-\/table associated with a given B\+R\+A\+N\+C\+H\+I\+ND. 

Look up the jump-\/table object with the matching \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} address 
\begin{DoxyParams}{Parameters}
{\em op} & is the given B\+R\+A\+N\+C\+H\+I\+ND \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the matching jump-\/table object or N\+U\+LL 
\end{DoxyReturn}
\mbox{\Hypertarget{classFuncdata_a9debba02fdd2a35a5bc5d7cd57fbcd5f}\label{classFuncdata_a9debba02fdd2a35a5bc5d7cd57fbcd5f}} 
\index{Funcdata@{Funcdata}!findLinkedVarnode@{findLinkedVarnode}}
\index{findLinkedVarnode@{findLinkedVarnode}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{findLinkedVarnode()}{findLinkedVarnode()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classVarnode}{Varnode}} $\ast$ Funcdata\+::find\+Linked\+Varnode (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classSymbolEntry}{Symbol\+Entry}} $\ast$}]{entry }\end{DoxyParamCaption}) const}



Find a \mbox{\hyperlink{classVarnode}{Varnode}} matching the given \mbox{\hyperlink{classSymbol}{Symbol}} mapping. 

Return the (first) \mbox{\hyperlink{classVarnode}{Varnode}} that matches the given \mbox{\hyperlink{classSymbolEntry}{Symbol\+Entry}} 
\begin{DoxyParams}{Parameters}
{\em entry} & is the given \mbox{\hyperlink{classSymbolEntry}{Symbol\+Entry}} \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a matching \mbox{\hyperlink{classVarnode}{Varnode}} or null 
\end{DoxyReturn}
\mbox{\Hypertarget{classFuncdata_a1b70ae4ce90305e74d143566a97f166f}\label{classFuncdata_a1b70ae4ce90305e74d143566a97f166f}} 
\index{Funcdata@{Funcdata}!findLinkedVarnodes@{findLinkedVarnodes}}
\index{findLinkedVarnodes@{findLinkedVarnodes}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{findLinkedVarnodes()}{findLinkedVarnodes()}}
{\footnotesize\ttfamily void Funcdata\+::find\+Linked\+Varnodes (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classSymbolEntry}{Symbol\+Entry}} $\ast$}]{entry,  }\item[{vector$<$ \mbox{\hyperlink{classVarnode}{Varnode}} $\ast$ $>$ \&}]{res }\end{DoxyParamCaption}) const}



Find Varnodes that map to the given \mbox{\hyperlink{classSymbolEntry}{Symbol\+Entry}}. 

Look for Varnodes that are (should be) mapped to the given \mbox{\hyperlink{classSymbolEntry}{Symbol\+Entry}} and add them to the end of the result list. 
\begin{DoxyParams}{Parameters}
{\em entry} & is the given \mbox{\hyperlink{classSymbolEntry}{Symbol\+Entry}} to match \\
\hline
{\em res} & is the container holding the result list of matching Varnodes \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classFuncdata_a1eee1ea3fa8e72d17549a936567c97bf}\label{classFuncdata_a1eee1ea3fa8e72d17549a936567c97bf}} 
\index{Funcdata@{Funcdata}!findSpacebaseInput@{findSpacebaseInput}}
\index{findSpacebaseInput@{findSpacebaseInput}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{findSpacebaseInput()}{findSpacebaseInput()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classVarnode}{Varnode}} $\ast$ Funcdata\+::find\+Spacebase\+Input (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classAddrSpace}{Addr\+Space}} $\ast$}]{id }\end{DoxyParamCaption}) const}

Given an address space, like {\itshape stack}, that is known to have a base register pointing to it, try to locate the unique \mbox{\hyperlink{classVarnode}{Varnode}} that holds the input value of this register. 
\begin{DoxyParams}{Parameters}
{\em id} & is the {\itshape stack} like address space \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the input stack-\/pointer \mbox{\hyperlink{classVarnode}{Varnode}} (or N\+U\+LL if it doesn\textquotesingle{}t exist) 
\end{DoxyReturn}
\mbox{\Hypertarget{classFuncdata_a718cc133e6ade757ee532f0d704c04d4}\label{classFuncdata_a718cc133e6ade757ee532f0d704c04d4}} 
\index{Funcdata@{Funcdata}!findVarnodeInput@{findVarnodeInput}}
\index{findVarnodeInput@{findVarnodeInput}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{findVarnodeInput()}{findVarnodeInput()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classVarnode}{Varnode}}$\ast$ Funcdata\+::find\+Varnode\+Input (\begin{DoxyParamCaption}\item[{int4}]{s,  }\item[{const \mbox{\hyperlink{classAddress}{Address}} \&}]{loc }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Find the input \mbox{\hyperlink{classVarnode}{Varnode}} with the given size and storage address. 


\begin{DoxyParams}{Parameters}
{\em s} & is the size in bytes \\
\hline
{\em loc} & is the storage address \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the matching \mbox{\hyperlink{classVarnode}{Varnode}} or N\+U\+LL 
\end{DoxyReturn}
\mbox{\Hypertarget{classFuncdata_acb7ae831db646e2f9d64ffb2b51fa7f1}\label{classFuncdata_acb7ae831db646e2f9d64ffb2b51fa7f1}} 
\index{Funcdata@{Funcdata}!findVarnodeWritten@{findVarnodeWritten}}
\index{findVarnodeWritten@{findVarnodeWritten}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{findVarnodeWritten()}{findVarnodeWritten()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classVarnode}{Varnode}}$\ast$ Funcdata\+::find\+Varnode\+Written (\begin{DoxyParamCaption}\item[{int4}]{s,  }\item[{const \mbox{\hyperlink{classAddress}{Address}} \&}]{loc,  }\item[{const \mbox{\hyperlink{classAddress}{Address}} \&}]{pc,  }\item[{uintm}]{uniq = {\ttfamily $\sim$((uintm)0)} }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Find a defined \mbox{\hyperlink{classVarnode}{Varnode}} via its storage address and its definition address. 


\begin{DoxyParams}{Parameters}
{\em s} & is the size in bytes \\
\hline
{\em loc} & is the storage address \\
\hline
{\em pc} & is the address where the \mbox{\hyperlink{classVarnode}{Varnode}} is defined \\
\hline
{\em uniq} & is an (optional) sequence number to match \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the matching \mbox{\hyperlink{classVarnode}{Varnode}} or N\+U\+LL 
\end{DoxyReturn}
\mbox{\Hypertarget{classFuncdata_a5c8f8e90f70db000a97d80677cdb133b}\label{classFuncdata_a5c8f8e90f70db000a97d80677cdb133b}} 
\index{Funcdata@{Funcdata}!followFlow@{followFlow}}
\index{followFlow@{followFlow}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{followFlow()}{followFlow()}}
{\footnotesize\ttfamily void Funcdata\+::follow\+Flow (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classAddress}{Address}} \&}]{baddr,  }\item[{const \mbox{\hyperlink{classAddress}{Address}} \&}]{eaddr }\end{DoxyParamCaption})}



Generate raw p-\/code for the function. 

Follow flow from the entry point generating Pcode\+Ops for each instruction encountered. The caller can provide a bounding range that constrains where control can flow to. 
\begin{DoxyParams}{Parameters}
{\em baddr} & is the beginning of the constraining range \\
\hline
{\em eaddr} & is the end of the constraining range \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classFuncdata_ac9b35091642dc7527a537d01db5ad7e1}\label{classFuncdata_ac9b35091642dc7527a537d01db5ad7e1}} 
\index{Funcdata@{Funcdata}!forceGoto@{forceGoto}}
\index{forceGoto@{forceGoto}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{forceGoto()}{forceGoto()}}
{\footnotesize\ttfamily bool Funcdata\+::force\+Goto (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classAddress}{Address}} \&}]{pcop,  }\item[{const \mbox{\hyperlink{classAddress}{Address}} \&}]{pcdest }\end{DoxyParamCaption})}



Force a specific control-\/flow edge to be marked as {\itshape unstructured}. 

The edge is specified by a source and destination \mbox{\hyperlink{classAddress}{Address}} (of the branch). The resulting control-\/flow structure will have a {\itshape goto} statement modeling the edge. 
\begin{DoxyParams}{Parameters}
{\em pcop} & is the source \mbox{\hyperlink{classAddress}{Address}} \\
\hline
{\em pcdest} & is the destination \mbox{\hyperlink{classAddress}{Address}} \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\bfseries{true}} if a control-\/flow edge was successfully labeled 
\end{DoxyReturn}
\mbox{\Hypertarget{classFuncdata_a97f6152575b9b9cbe1c5c447a78efcd3}\label{classFuncdata_a97f6152575b9b9cbe1c5c447a78efcd3}} 
\index{Funcdata@{Funcdata}!getFirstReturnOp@{getFirstReturnOp}}
\index{getFirstReturnOp@{getFirstReturnOp}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{getFirstReturnOp()}{getFirstReturnOp()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$ Funcdata\+::get\+First\+Return\+Op (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption}) const}



Clone a \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} into {\bfseries{this}} function. 

Return the first C\+P\+U\+I\+\_\+\+R\+E\+T\+U\+RN operation that is not dead or an artificial halt \begin{DoxyReturn}{Returns}
a representative C\+P\+U\+I\+\_\+\+R\+E\+T\+U\+RN op or N\+U\+LL if there are none 
\end{DoxyReturn}
\mbox{\Hypertarget{classFuncdata_ae349f4a44febd9dd27ca63f7f8840103}\label{classFuncdata_ae349f4a44febd9dd27ca63f7f8840103}} 
\index{Funcdata@{Funcdata}!hasRestartPending@{hasRestartPending}}
\index{hasRestartPending@{hasRestartPending}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{hasRestartPending()}{hasRestartPending()}}
{\footnotesize\ttfamily bool Funcdata\+::has\+Restart\+Pending (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Does {\bfseries{this}} function need to restart its analysis. 

\begin{DoxyReturn}{Returns}
{\bfseries{true}} if analysis should be restarted 
\end{DoxyReturn}
\mbox{\Hypertarget{classFuncdata_afef27da9040d28296accaaa1c1982401}\label{classFuncdata_afef27da9040d28296accaaa1c1982401}} 
\index{Funcdata@{Funcdata}!hasUnimplemented@{hasUnimplemented}}
\index{hasUnimplemented@{hasUnimplemented}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{hasUnimplemented()}{hasUnimplemented()}}
{\footnotesize\ttfamily bool Funcdata\+::has\+Unimplemented (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Does {\bfseries{this}} function have instructions marked as {\itshape unimplemented}. 

\begin{DoxyReturn}{Returns}
{\bfseries{true}} if the function\textquotesingle{}s body contains at least one unimplemented instruction 
\end{DoxyReturn}
\mbox{\Hypertarget{classFuncdata_ae454fbd3566fbd43103dcabdf2681fd8}\label{classFuncdata_ae454fbd3566fbd43103dcabdf2681fd8}} 
\index{Funcdata@{Funcdata}!initActiveOutput@{initActiveOutput}}
\index{initActiveOutput@{initActiveOutput}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{initActiveOutput()}{initActiveOutput()}}
{\footnotesize\ttfamily void Funcdata\+::init\+Active\+Output (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}

Initialize {\itshape return} prototype recovery analysis \mbox{\Hypertarget{classFuncdata_a3bcc11dc2a2eefa48bc4b244094a521f}\label{classFuncdata_a3bcc11dc2a2eefa48bc4b244094a521f}} 
\index{Funcdata@{Funcdata}!inlineFlow@{inlineFlow}}
\index{inlineFlow@{inlineFlow}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{inlineFlow()}{inlineFlow()}}
{\footnotesize\ttfamily bool Funcdata\+::inline\+Flow (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classFuncdata}{Funcdata}} $\ast$}]{inlinefd,  }\item[{\mbox{\hyperlink{classFlowInfo}{Flow\+Info}} \&}]{flow,  }\item[{\mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$}]{callop }\end{DoxyParamCaption})}



In-\/line the p-\/code from another function into {\bfseries{this}} function. 

Raw Pcode\+Ops for the in-\/line function are generated and then cloned into {\bfseries{this}} function. Depending on the control-\/flow complexity of the in-\/line function, the Pcode\+Ops are injected as if they are all part of the call site address (E\+Z\+Model), or the Pcode\+Ops preserve their address and extra branch instructions are inserted to integrate control-\/flow of the in-\/line into the calling function. 
\begin{DoxyParams}{Parameters}
{\em inlinefd} & is the function to in-\/line \\
\hline
{\em flow} & is the flow object being injected \\
\hline
{\em callop} & is the site of the injection \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\bfseries{true}} if the injection was successful 
\end{DoxyReturn}
\mbox{\Hypertarget{classFuncdata_a337a544e372368eb5c41b1bb5e410932}\label{classFuncdata_a337a544e372368eb5c41b1bb5e410932}} 
\index{Funcdata@{Funcdata}!installJumpTable@{installJumpTable}}
\index{installJumpTable@{installJumpTable}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{installJumpTable()}{installJumpTable()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classJumpTable}{Jump\+Table}} $\ast$ Funcdata\+::install\+Jump\+Table (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classAddress}{Address}} \&}]{addr }\end{DoxyParamCaption})}



Install a new jump-\/table for the given \mbox{\hyperlink{classAddress}{Address}}. 

The given address must have a B\+R\+A\+N\+C\+H\+I\+ND op attached to it. This is suitable for installing an override and must be called before flow has been traced. 
\begin{DoxyParams}{Parameters}
{\em addr} & is the given \mbox{\hyperlink{classAddress}{Address}} \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the new jump-\/table object 
\end{DoxyReturn}
\mbox{\Hypertarget{classFuncdata_a803cbb38fe59825f59858a16afa54b7d}\label{classFuncdata_a803cbb38fe59825f59858a16afa54b7d}} 
\index{Funcdata@{Funcdata}!isHeritaged@{isHeritaged}}
\index{isHeritaged@{isHeritaged}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{isHeritaged()}{isHeritaged()}}
{\footnotesize\ttfamily bool Funcdata\+::is\+Heritaged (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classVarnode}{Varnode}} $\ast$}]{vn }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Check if a specific \mbox{\hyperlink{classVarnode}{Varnode}} has been linked in fully to the syntax tree (S\+SA) 


\begin{DoxyParams}{Parameters}
{\em vn} & is the specific \mbox{\hyperlink{classVarnode}{Varnode}} \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\bfseries{true}} if the \mbox{\hyperlink{classVarnode}{Varnode}} is fully linked 
\end{DoxyReturn}
\mbox{\Hypertarget{classFuncdata_a512f5823b1a33e9430584067d77a52c5}\label{classFuncdata_a512f5823b1a33e9430584067d77a52c5}} 
\index{Funcdata@{Funcdata}!linkJumpTable@{linkJumpTable}}
\index{linkJumpTable@{linkJumpTable}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{linkJumpTable()}{linkJumpTable()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classJumpTable}{Jump\+Table}} $\ast$ Funcdata\+::link\+Jump\+Table (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$}]{op }\end{DoxyParamCaption})}



Link jump-\/table with a given B\+R\+A\+N\+C\+H\+I\+ND. 

Look up the jump-\/table object with the matching \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} address, then attach the given \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} to it. 
\begin{DoxyParams}{Parameters}
{\em op} & is the given B\+R\+A\+N\+C\+H\+I\+ND \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the matching jump-\/table object or N\+U\+LL 
\end{DoxyReturn}
\mbox{\Hypertarget{classFuncdata_afbb3bc5ac9e2c09eda544db34b8f5879}\label{classFuncdata_afbb3bc5ac9e2c09eda544db34b8f5879}} 
\index{Funcdata@{Funcdata}!linkSymbol@{linkSymbol}}
\index{linkSymbol@{linkSymbol}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{linkSymbol()}{linkSymbol()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classSymbol}{Symbol}} $\ast$ Funcdata\+::link\+Symbol (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classVarnode}{Varnode}} $\ast$}]{vn }\end{DoxyParamCaption})}



Find or create \mbox{\hyperlink{classSymbol}{Symbol}} associated with given \mbox{\hyperlink{classVarnode}{Varnode}}. 

The \mbox{\hyperlink{classSymbol}{Symbol}} is really attached to the \mbox{\hyperlink{classVarnode}{Varnode}}\textquotesingle{}s \mbox{\hyperlink{classHighVariable}{High\+Variable}} (which must exist). The only reason a \mbox{\hyperlink{classSymbol}{Symbol}} doesn\textquotesingle{}t get set is if, the \mbox{\hyperlink{classHighVariable}{High\+Variable}} is global and there is no pre-\/existing \mbox{\hyperlink{classSymbol}{Symbol}}. (see \mbox{\hyperlink{classFuncdata_aed6aefa7321e887e3b759de94e4d3d4f}{map\+Globals()}}) 
\begin{DoxyParams}{Parameters}
{\em vn} & is the given \mbox{\hyperlink{classVarnode}{Varnode}} \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the associated \mbox{\hyperlink{classSymbol}{Symbol}} or N\+U\+LL 
\end{DoxyReturn}
\mbox{\Hypertarget{classFuncdata_a736351e8eb6c044fe00deb0cf7e6b5c5}\label{classFuncdata_a736351e8eb6c044fe00deb0cf7e6b5c5}} 
\index{Funcdata@{Funcdata}!linkSymbolReference@{linkSymbolReference}}
\index{linkSymbolReference@{linkSymbolReference}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{linkSymbolReference()}{linkSymbolReference()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classSymbol}{Symbol}} $\ast$ Funcdata\+::link\+Symbol\+Reference (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classVarnode}{Varnode}} $\ast$}]{vn }\end{DoxyParamCaption})}



Discover and attach \mbox{\hyperlink{classSymbol}{Symbol}} to a constant reference. 

A reference to a symbol (i.\+e. \&varname) is typically stored as a P\+T\+R\+S\+UB operation, where the first input \mbox{\hyperlink{classVarnode}{Varnode}} is a {\itshape spacebase} \mbox{\hyperlink{classVarnode}{Varnode}} indicating whether the symbol is on the {\itshape stack} or at a {\itshape global} R\+AM location. The second input \mbox{\hyperlink{classVarnode}{Varnode}} is a constant encoding the address of the symbol. This method takes this constant \mbox{\hyperlink{classVarnode}{Varnode}}, recovers the symbol it is referring to, and stores on the \mbox{\hyperlink{classHighVariable}{High\+Variable}} object attached to the \mbox{\hyperlink{classVarnode}{Varnode}}. 
\begin{DoxyParams}{Parameters}
{\em vn} & is the constant \mbox{\hyperlink{classVarnode}{Varnode}} (second input) to a P\+T\+R\+S\+UB operation \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the symbol being referred to or null 
\end{DoxyReturn}
\mbox{\Hypertarget{classFuncdata_aed6aefa7321e887e3b759de94e4d3d4f}\label{classFuncdata_aed6aefa7321e887e3b759de94e4d3d4f}} 
\index{Funcdata@{Funcdata}!mapGlobals@{mapGlobals}}
\index{mapGlobals@{mapGlobals}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{mapGlobals()}{mapGlobals()}}
{\footnotesize\ttfamily void Funcdata\+::map\+Globals (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Make sure there is a \mbox{\hyperlink{classSymbol}{Symbol}} entry for all global Varnodes. 

Search for {\itshape addrtied} Varnodes whose storage falls in the global \mbox{\hyperlink{classScope}{Scope}}, then build a new global \mbox{\hyperlink{classSymbol}{Symbol}} if one didn\textquotesingle{}t exist before. \mbox{\Hypertarget{classFuncdata_a90af6702bb2cf33ecc7dee059b6e3eb9}\label{classFuncdata_a90af6702bb2cf33ecc7dee059b6e3eb9}} 
\index{Funcdata@{Funcdata}!markIndirectCreation@{markIndirectCreation}}
\index{markIndirectCreation@{markIndirectCreation}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{markIndirectCreation()}{markIndirectCreation()}}
{\footnotesize\ttfamily void Funcdata\+::mark\+Indirect\+Creation (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$}]{indop,  }\item[{bool}]{possible\+Output }\end{DoxyParamCaption})}



Convert C\+P\+U\+I\+\_\+\+I\+N\+D\+I\+R\+E\+CT into an {\itshape indirect} {\itshape creation}. 

Data-\/flow through the given C\+P\+U\+I\+\_\+\+I\+N\+D\+I\+R\+E\+CT op is marked so that the output \mbox{\hyperlink{classVarnode}{Varnode}} is considered {\itshape indirectly} {\itshape created}. An {\itshape indirectly} {\itshape created} \mbox{\hyperlink{classVarnode}{Varnode}} effectively has no data-\/flow before the I\+N\+D\+I\+R\+E\+CT op that defines it, and the value contained by the \mbox{\hyperlink{classVarnode}{Varnode}} is not explicitly calculable. 
\begin{DoxyParams}{Parameters}
{\em indop} & is the given C\+P\+U\+I\+\_\+\+I\+N\+D\+I\+R\+E\+CT op \\
\hline
{\em possible\+Output} & is {\bfseries{true}} if I\+N\+D\+I\+R\+E\+CT should be marked as a possible call output \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classFuncdata_a41dc1e061256c4cc55e7afcf5995f435}\label{classFuncdata_a41dc1e061256c4cc55e7afcf5995f435}} 
\index{Funcdata@{Funcdata}!markIndirectOnly@{markIndirectOnly}}
\index{markIndirectOnly@{markIndirectOnly}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{markIndirectOnly()}{markIndirectOnly()}}
{\footnotesize\ttfamily void Funcdata\+::mark\+Indirect\+Only (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Mark {\itshape illegal} {\itshape input} Varnodes used only in I\+N\+D\+I\+R\+E\+C\+Ts. 

The illegal inputs are additionally marked as {\bfseries{indirectonly}} and is\+Indirect\+Only() returns {\bfseries{true}}. \mbox{\Hypertarget{classFuncdata_a63f8f05085e81b696eb3f1b4dcf398be}\label{classFuncdata_a63f8f05085e81b696eb3f1b4dcf398be}} 
\index{Funcdata@{Funcdata}!moveRespectingCover@{moveRespectingCover}}
\index{moveRespectingCover@{moveRespectingCover}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{moveRespectingCover()}{moveRespectingCover()}}
{\footnotesize\ttfamily bool Funcdata\+::move\+Respecting\+Cover (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$}]{op,  }\item[{\mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$}]{last\+Op }\end{DoxyParamCaption})}



Move given op past {\itshape last\+Op} respecting covers if possible. 

This routine should be called only after \mbox{\hyperlink{classVarnode}{Varnode}} merging and explicit/implicit attributes have been calculated. Determine if the given op can be moved (only within its basic block) to after {\itshape last\+Op}. The output of any \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} moved across must not be involved, directly or indirectly, with any variable in the expression rooted at the given op. If the move is possible, perform the move. 
\begin{DoxyParams}{Parameters}
{\em op} & is the given \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} \\
\hline
{\em last\+Op} & is the \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} to move past \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\bfseries{true}} if the move is possible 
\end{DoxyReturn}
\mbox{\Hypertarget{classFuncdata_a24e80f56ef371a0010a9e67ae8510086}\label{classFuncdata_a24e80f56ef371a0010a9e67ae8510086}} 
\index{Funcdata@{Funcdata}!newCodeRef@{newCodeRef}}
\index{newCodeRef@{newCodeRef}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{newCodeRef()}{newCodeRef()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classVarnode}{Varnode}} $\ast$ Funcdata\+::new\+Code\+Ref (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classAddress}{Address}} \&}]{m }\end{DoxyParamCaption})}



Create a code address {\itshape annotation} \mbox{\hyperlink{classVarnode}{Varnode}}. 

A reference to a specific \mbox{\hyperlink{classAddress}{Address}} is encoded in a \mbox{\hyperlink{classVarnode}{Varnode}}. The \mbox{\hyperlink{classVarnode}{Varnode}} is an {\itshape annotation} in the sense that it will hold no value in the data-\/flow, it will will only hold a reference to an address. This is used specifically by the branch p-\/code operations to hold destination addresses. 
\begin{DoxyParams}{Parameters}
{\em m} & is the \mbox{\hyperlink{classAddress}{Address}} to encode \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the newly allocated {\itshape annotation} \mbox{\hyperlink{classVarnode}{Varnode}} 
\end{DoxyReturn}
\mbox{\Hypertarget{classFuncdata_af58542dbcc89f4b84ffc8834b023125b}\label{classFuncdata_af58542dbcc89f4b84ffc8834b023125b}} 
\index{Funcdata@{Funcdata}!newConstant@{newConstant}}
\index{newConstant@{newConstant}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{newConstant()}{newConstant()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classVarnode}{Varnode}} $\ast$ Funcdata\+::new\+Constant (\begin{DoxyParamCaption}\item[{int4}]{s,  }\item[{uintb}]{constant\+\_\+val }\end{DoxyParamCaption})}



Create a new {\itshape constant} \mbox{\hyperlink{classVarnode}{Varnode}}. 

A \mbox{\hyperlink{classVarnode}{Varnode}} is allocated which represents the indicated constant value. Its storage address is in the {\itshape constant} address space. 
\begin{DoxyParams}{Parameters}
{\em s} & is the size of the \mbox{\hyperlink{classVarnode}{Varnode}} in bytes \\
\hline
{\em constant\+\_\+val} & is the indicated constant value \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the new \mbox{\hyperlink{classVarnode}{Varnode}} object 
\end{DoxyReturn}
\mbox{\Hypertarget{classFuncdata_add1098b768d9a176cf59e4f4c9e27cb5}\label{classFuncdata_add1098b768d9a176cf59e4f4c9e27cb5}} 
\index{Funcdata@{Funcdata}!newIndirectCreation@{newIndirectCreation}}
\index{newIndirectCreation@{newIndirectCreation}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{newIndirectCreation()}{newIndirectCreation()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$ Funcdata\+::new\+Indirect\+Creation (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$}]{indeffect,  }\item[{const \mbox{\hyperlink{classAddress}{Address}} \&}]{addr,  }\item[{int4}]{size,  }\item[{bool}]{possibleout }\end{DoxyParamCaption})}



Build a C\+P\+U\+I\+\_\+\+I\+N\+D\+I\+R\+E\+CT op that {\itshape indirectly} {\itshape creates} a \mbox{\hyperlink{classVarnode}{Varnode}}. 

An {\itshape indirectly} {\itshape created} \mbox{\hyperlink{classVarnode}{Varnode}} effectively has no data-\/flow before the I\+N\+D\+I\+R\+E\+CT op that defines it, and the value contained by the \mbox{\hyperlink{classVarnode}{Varnode}} is not explicitly calculable. The new \mbox{\hyperlink{classVarnode}{Varnode}} is allocated with a given storage range. 
\begin{DoxyParams}{Parameters}
{\em indeffect} & is the p-\/code causing the indirect effect \\
\hline
{\em addr} & is the starting address of the given storage range \\
\hline
{\em size} & is the number of bytes in the storage range \\
\hline
{\em possibleout} & is {\bfseries{true}} if the output should be treated as a {\itshape directwrite}. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the new C\+P\+U\+I\+\_\+\+I\+N\+D\+I\+R\+E\+CT op 
\end{DoxyReturn}
\mbox{\Hypertarget{classFuncdata_a008246c0350878f3d312b174a227b676}\label{classFuncdata_a008246c0350878f3d312b174a227b676}} 
\index{Funcdata@{Funcdata}!newIndirectOp@{newIndirectOp}}
\index{newIndirectOp@{newIndirectOp}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{newIndirectOp()}{newIndirectOp()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$ Funcdata\+::new\+Indirect\+Op (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$}]{indeffect,  }\item[{const \mbox{\hyperlink{classAddress}{Address}} \&}]{addr,  }\item[{int4}]{size,  }\item[{uint4}]{extra\+Flags }\end{DoxyParamCaption})}



Find a representative C\+P\+U\+I\+\_\+\+R\+E\+T\+U\+RN op for {\bfseries{this}} function. 

Create a new C\+P\+U\+I\+\_\+\+I\+N\+D\+I\+R\+E\+CT around a \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} with an indirect effect.

Typically this is used to annotate data-\/flow, for the given storage range, passing through a C\+A\+LL or S\+T\+O\+RE. An output \mbox{\hyperlink{classVarnode}{Varnode}} is automatically created. 
\begin{DoxyParams}{Parameters}
{\em indeffect} & is the \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} with the indirect effect \\
\hline
{\em addr} & is the starting address of the storage range to protect \\
\hline
{\em size} & is the number of bytes in the storage range \\
\hline
{\em extra\+Flags} & are extra boolean properties to put on the I\+N\+D\+I\+R\+E\+CT \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the new C\+P\+U\+I\+\_\+\+I\+N\+D\+I\+R\+E\+CT op 
\end{DoxyReturn}
\mbox{\Hypertarget{classFuncdata_a1b1e9831bb4b1c65df6950ae1f15e0be}\label{classFuncdata_a1b1e9831bb4b1c65df6950ae1f15e0be}} 
\index{Funcdata@{Funcdata}!newOp@{newOp}}
\index{newOp@{newOp}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{newOp()}{newOp()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$ Funcdata\+::new\+Op (\begin{DoxyParamCaption}\item[{int4}]{inputs,  }\item[{const \mbox{\hyperlink{classAddress}{Address}} \&}]{pc }\end{DoxyParamCaption})}


\begin{DoxyParams}{Parameters}
{\em inputs} & is the number of operands the new op will have \\
\hline
{\em pc} & is the \mbox{\hyperlink{classAddress}{Address}} associated with the new op \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the new \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} 
\end{DoxyReturn}
\mbox{\Hypertarget{classFuncdata_a0d122aa09d739e59a5107338f8ecd8ab}\label{classFuncdata_a0d122aa09d739e59a5107338f8ecd8ab}} 
\index{Funcdata@{Funcdata}!newOp@{newOp}}
\index{newOp@{newOp}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{newOp()}{newOp()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$ Funcdata\+::new\+Op (\begin{DoxyParamCaption}\item[{int4}]{inputs,  }\item[{const \mbox{\hyperlink{classSeqNum}{Seq\+Num}} \&}]{sq }\end{DoxyParamCaption})}



Allocate a new \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} with \mbox{\hyperlink{classAddress}{Address}}. 

This method is typically used for cloning. 
\begin{DoxyParams}{Parameters}
{\em inputs} & is the number of operands the new op will have \\
\hline
{\em sq} & is the sequence number (\mbox{\hyperlink{classAddress}{Address}} and sub-\/index) of the new op \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the new \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} 
\end{DoxyReturn}
\mbox{\Hypertarget{classFuncdata_ae1126d213d88120c9e55b5779d746859}\label{classFuncdata_ae1126d213d88120c9e55b5779d746859}} 
\index{Funcdata@{Funcdata}!newOpBefore@{newOpBefore}}
\index{newOpBefore@{newOpBefore}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{newOpBefore()}{newOpBefore()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$ Funcdata\+::new\+Op\+Before (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$}]{follow,  }\item[{\mbox{\hyperlink{opcodes_8hh_abeb7dfb0e9e2b3114e240a405d046ea7}{Op\+Code}}}]{opc,  }\item[{\mbox{\hyperlink{classVarnode}{Varnode}} $\ast$}]{in1,  }\item[{\mbox{\hyperlink{classVarnode}{Varnode}} $\ast$}]{in2,  }\item[{\mbox{\hyperlink{classVarnode}{Varnode}} $\ast$}]{in3 = {\ttfamily (\mbox{\hyperlink{classVarnode}{Varnode}}~$\ast$)0} }\end{DoxyParamCaption})}



Allocate a new \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} with sequence number. 

Create new \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} with 2 or 3 given operands.

The new op will have a {\itshape unique} space output \mbox{\hyperlink{classVarnode}{Varnode}} and will be inserted before the given {\itshape follow} op. 
\begin{DoxyParams}{Parameters}
{\em follow} & is the {\itshape follow} up to insert the new \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} before \\
\hline
{\em opc} & is the op-\/code of the new \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} \\
\hline
{\em in1} & is the first operand \\
\hline
{\em in2} & is the second operand \\
\hline
{\em in3} & is the optional third param \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the new \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} 
\end{DoxyReturn}
\mbox{\Hypertarget{classFuncdata_ac083b7d6637a5883ef8cbd38e7756837}\label{classFuncdata_ac083b7d6637a5883ef8cbd38e7756837}} 
\index{Funcdata@{Funcdata}!newSpacebasePtr@{newSpacebasePtr}}
\index{newSpacebasePtr@{newSpacebasePtr}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{newSpacebasePtr()}{newSpacebasePtr()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classVarnode}{Varnode}} $\ast$ Funcdata\+::new\+Spacebase\+Ptr (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classAddrSpace}{Addr\+Space}} $\ast$}]{id }\end{DoxyParamCaption})}



Construct a new {\itshape spacebase} register for a given address space. 

Given an address space, like {\itshape stack}, that is known to have a base register pointing to it, construct a \mbox{\hyperlink{classVarnode}{Varnode}} representing that register. 
\begin{DoxyParams}{Parameters}
{\em id} & is the {\itshape stack} like address space \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a newly allocated stack-\/pointer \mbox{\hyperlink{classVarnode}{Varnode}} 
\end{DoxyReturn}
\mbox{\Hypertarget{classFuncdata_a731f6fd415269577b7bb1943315b8a76}\label{classFuncdata_a731f6fd415269577b7bb1943315b8a76}} 
\index{Funcdata@{Funcdata}!newUnique@{newUnique}}
\index{newUnique@{newUnique}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{newUnique()}{newUnique()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classVarnode}{Varnode}} $\ast$ Funcdata\+::new\+Unique (\begin{DoxyParamCaption}\item[{int4}]{s,  }\item[{\mbox{\hyperlink{classDatatype}{Datatype}} $\ast$}]{ct = {\ttfamily (\mbox{\hyperlink{classDatatype}{Datatype}}~$\ast$)0} }\end{DoxyParamCaption})}



Create a new {\itshape temporary} \mbox{\hyperlink{classVarnode}{Varnode}}. 

A new temporary register storage location is allocated from the {\itshape unique} address space 
\begin{DoxyParams}{Parameters}
{\em s} & is the size of the \mbox{\hyperlink{classVarnode}{Varnode}} in bytes \\
\hline
{\em ct} & is an optional data-\/type to associated with the \mbox{\hyperlink{classVarnode}{Varnode}} \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the newly allocated {\itshape temporary} \mbox{\hyperlink{classVarnode}{Varnode}} 
\end{DoxyReturn}
\mbox{\Hypertarget{classFuncdata_af189a9a5b390332c6e87c8faa334cd68}\label{classFuncdata_af189a9a5b390332c6e87c8faa334cd68}} 
\index{Funcdata@{Funcdata}!newUniqueOut@{newUniqueOut}}
\index{newUniqueOut@{newUniqueOut}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{newUniqueOut()}{newUniqueOut()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classVarnode}{Varnode}} $\ast$ Funcdata\+::new\+Unique\+Out (\begin{DoxyParamCaption}\item[{int4}]{s,  }\item[{\mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$}]{op }\end{DoxyParamCaption})}



Create a new {\itshape temporary} output \mbox{\hyperlink{classVarnode}{Varnode}}. 

Allocate a new register from the {\itshape unique} address space and create a new \mbox{\hyperlink{classVarnode}{Varnode}} object representing it as an output to the given \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} 
\begin{DoxyParams}{Parameters}
{\em s} & is the size of the new \mbox{\hyperlink{classVarnode}{Varnode}} in bytes \\
\hline
{\em op} & is the given \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} whose output is created \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the new temporary register \mbox{\hyperlink{classVarnode}{Varnode}} 
\end{DoxyReturn}
\mbox{\Hypertarget{classFuncdata_a0d6888d1606fd8ed6372355995bc7887}\label{classFuncdata_a0d6888d1606fd8ed6372355995bc7887}} 
\index{Funcdata@{Funcdata}!newVarnode@{newVarnode}}
\index{newVarnode@{newVarnode}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{newVarnode()}{newVarnode()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{classVarnode}{Varnode}} $\ast$ Funcdata\+::new\+Varnode (\begin{DoxyParamCaption}\item[{int4}]{s,  }\item[{\mbox{\hyperlink{classAddrSpace}{Addr\+Space}} $\ast$}]{base,  }\item[{uintb}]{off }\end{DoxyParamCaption})}



Create a new \mbox{\hyperlink{classVarnode}{Varnode}} given an address space and offset. 


\begin{DoxyParams}{Parameters}
{\em s} & is the size of the \mbox{\hyperlink{classVarnode}{Varnode}} in bytes \\
\hline
{\em base} & is the address space of the \mbox{\hyperlink{classVarnode}{Varnode}} \\
\hline
{\em off} & is the offset into the address space of the \mbox{\hyperlink{classVarnode}{Varnode}} \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the newly allocated \mbox{\hyperlink{classVarnode}{Varnode}} 
\end{DoxyReturn}
\mbox{\Hypertarget{classFuncdata_a22894e1c7b0f30a5391993924cd96d3d}\label{classFuncdata_a22894e1c7b0f30a5391993924cd96d3d}} 
\index{Funcdata@{Funcdata}!newVarnode@{newVarnode}}
\index{newVarnode@{newVarnode}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{newVarnode()}{newVarnode()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{classVarnode}{Varnode}} $\ast$ Funcdata\+::new\+Varnode (\begin{DoxyParamCaption}\item[{int4}]{s,  }\item[{const \mbox{\hyperlink{classAddress}{Address}} \&}]{m,  }\item[{\mbox{\hyperlink{classDatatype}{Datatype}} $\ast$}]{ct = {\ttfamily (\mbox{\hyperlink{classDatatype}{Datatype}}~$\ast$)0} }\end{DoxyParamCaption})}



Create a new unattached \mbox{\hyperlink{classVarnode}{Varnode}} object. 


\begin{DoxyParams}{Parameters}
{\em s} & is the size of the new \mbox{\hyperlink{classVarnode}{Varnode}} in bytes \\
\hline
{\em m} & is the storage \mbox{\hyperlink{classAddress}{Address}} of the \mbox{\hyperlink{classVarnode}{Varnode}} \\
\hline
{\em ct} & is a data-\/type to associate with the \mbox{\hyperlink{classVarnode}{Varnode}} \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the newly allocated \mbox{\hyperlink{classVarnode}{Varnode}} object 
\end{DoxyReturn}
\mbox{\Hypertarget{classFuncdata_a13da637294b7cae252ffc6c9e2116da2}\label{classFuncdata_a13da637294b7cae252ffc6c9e2116da2}} 
\index{Funcdata@{Funcdata}!newVarnodeCallSpecs@{newVarnodeCallSpecs}}
\index{newVarnodeCallSpecs@{newVarnodeCallSpecs}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{newVarnodeCallSpecs()}{newVarnodeCallSpecs()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classVarnode}{Varnode}} $\ast$ Funcdata\+::new\+Varnode\+Call\+Specs (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classFuncCallSpecs}{Func\+Call\+Specs}} $\ast$}]{fc }\end{DoxyParamCaption})}



Create a call specification {\itshape annotation} \mbox{\hyperlink{classVarnode}{Varnode}}. 

A call specification (\mbox{\hyperlink{classFuncCallSpecs}{Func\+Call\+Specs}}) is encoded into an {\itshape annotation} \mbox{\hyperlink{classVarnode}{Varnode}}. The \mbox{\hyperlink{classVarnode}{Varnode}} is used specifically as an input to C\+P\+U\+I\+\_\+\+C\+A\+LL ops to speed up access to their associated call specification. 
\begin{DoxyParams}{Parameters}
{\em fc} & is the call specification to encode \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the newly allocated {\itshape annotation} \mbox{\hyperlink{classVarnode}{Varnode}} 
\end{DoxyReturn}
\mbox{\Hypertarget{classFuncdata_a8ee39fe2d1f2f4702864e78dc06e6bb8}\label{classFuncdata_a8ee39fe2d1f2f4702864e78dc06e6bb8}} 
\index{Funcdata@{Funcdata}!newVarnodeIop@{newVarnodeIop}}
\index{newVarnodeIop@{newVarnodeIop}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{newVarnodeIop()}{newVarnodeIop()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classVarnode}{Varnode}} $\ast$ Funcdata\+::new\+Varnode\+Iop (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$}]{op }\end{DoxyParamCaption})}



Create a \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} {\itshape annotation} \mbox{\hyperlink{classVarnode}{Varnode}}. 

Create a special {\itshape annotation} \mbox{\hyperlink{classVarnode}{Varnode}} that holds a pointer reference to a specific \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}}. This is used specifically to let a C\+P\+U\+I\+\_\+\+I\+N\+D\+I\+R\+E\+CT op refer to the \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} it is holding an indirect effect for. 
\begin{DoxyParams}{Parameters}
{\em op} & is the \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} to encode in the annotation \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the newly allocated {\itshape annotation} \mbox{\hyperlink{classVarnode}{Varnode}} 
\end{DoxyReturn}
\mbox{\Hypertarget{classFuncdata_a100e6704e4c245e076170268d31b47ec}\label{classFuncdata_a100e6704e4c245e076170268d31b47ec}} 
\index{Funcdata@{Funcdata}!newVarnodeOut@{newVarnodeOut}}
\index{newVarnodeOut@{newVarnodeOut}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{newVarnodeOut()}{newVarnodeOut()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classVarnode}{Varnode}} $\ast$ Funcdata\+::new\+Varnode\+Out (\begin{DoxyParamCaption}\item[{int4}]{s,  }\item[{const \mbox{\hyperlink{classAddress}{Address}} \&}]{m,  }\item[{\mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$}]{op }\end{DoxyParamCaption})}



Create a new output \mbox{\hyperlink{classVarnode}{Varnode}}. 

Create a new \mbox{\hyperlink{classVarnode}{Varnode}} which is already defined as output of a given \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}}. This if more efficient as it avoids the initial insertion of the free form of the \mbox{\hyperlink{classVarnode}{Varnode}} into the tree, and query\+Properties only needs to be called once. 
\begin{DoxyParams}{Parameters}
{\em s} & is the size of the new \mbox{\hyperlink{classVarnode}{Varnode}} in bytes \\
\hline
{\em m} & is the storage \mbox{\hyperlink{classAddress}{Address}} of the \mbox{\hyperlink{classVarnode}{Varnode}} \\
\hline
{\em op} & is the given \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} whose output is created \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the new \mbox{\hyperlink{classVarnode}{Varnode}} object 
\end{DoxyReturn}
\mbox{\Hypertarget{classFuncdata_acc9f6fb3e8a36e0e1e633660fc05fdbf}\label{classFuncdata_acc9f6fb3e8a36e0e1e633660fc05fdbf}} 
\index{Funcdata@{Funcdata}!newVarnodeSpace@{newVarnodeSpace}}
\index{newVarnodeSpace@{newVarnodeSpace}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{newVarnodeSpace()}{newVarnodeSpace()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classVarnode}{Varnode}} $\ast$ Funcdata\+::new\+Varnode\+Space (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classAddrSpace}{Addr\+Space}} $\ast$}]{spc }\end{DoxyParamCaption})}



Create a constant \mbox{\hyperlink{classVarnode}{Varnode}} referring to an address space. 

A reference to a particular address space is encoded as a constant \mbox{\hyperlink{classVarnode}{Varnode}}. These are used for L\+O\+AD and S\+T\+O\+RE p-\/code ops in particular. 
\begin{DoxyParams}{Parameters}
{\em spc} & is the address space to encode \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the newly allocated constant \mbox{\hyperlink{classVarnode}{Varnode}} 
\end{DoxyReturn}
\mbox{\Hypertarget{classFuncdata_ad810c24ce5fb16a95de1f7d27c8856d8}\label{classFuncdata_ad810c24ce5fb16a95de1f7d27c8856d8}} 
\index{Funcdata@{Funcdata}!nodeJoinCreateBlock@{nodeJoinCreateBlock}}
\index{nodeJoinCreateBlock@{nodeJoinCreateBlock}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{nodeJoinCreateBlock()}{nodeJoinCreateBlock()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classBlockBasic}{Block\+Basic}} $\ast$ Funcdata\+::node\+Join\+Create\+Block (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classBlockBasic}{Block\+Basic}} $\ast$}]{block1,  }\item[{\mbox{\hyperlink{classBlockBasic}{Block\+Basic}} $\ast$}]{block2,  }\item[{\mbox{\hyperlink{classBlockBasic}{Block\+Basic}} $\ast$}]{exita,  }\item[{\mbox{\hyperlink{classBlockBasic}{Block\+Basic}} $\ast$}]{exitb,  }\item[{bool}]{fora\+\_\+block1ishigh,  }\item[{bool}]{forb\+\_\+block1ishigh,  }\item[{const \mbox{\hyperlink{classAddress}{Address}} \&}]{addr }\end{DoxyParamCaption})}



Create a new basic block for holding a merged C\+B\+R\+A\+N\+CH. 

This is used by \mbox{\hyperlink{classConditionalJoin}{Conditional\+Join}} to do the low-\/level control-\/flow manipulation to merge identical conditional branches. Given basic blocks containing the two C\+B\+R\+A\+N\+CH ops to merge, the new block gets one of the two out edges from each block, and the remaining out edges are changed to point into the new block. 
\begin{DoxyParams}{Parameters}
{\em block1} & is the basic block containing the first C\+B\+R\+A\+N\+CH to merge \\
\hline
{\em block2} & is the basic block containing the second C\+B\+R\+A\+N\+CH \\
\hline
{\em exita} & is the first common exit block for the C\+B\+R\+A\+N\+C\+Hs \\
\hline
{\em exitb} & is the second common exit block \\
\hline
{\em fora\+\_\+block1ishigh} & designates which edge is moved for exita \\
\hline
{\em forb\+\_\+block1ishigh} & designates which edge is moved for exitb \\
\hline
{\em addr} & is the \mbox{\hyperlink{classAddress}{Address}} associated with (1 of the) C\+B\+R\+A\+N\+CH ops \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the new basic block 
\end{DoxyReturn}
\mbox{\Hypertarget{classFuncdata_a3e19baf8aa1db2ecde4fd12075da0694}\label{classFuncdata_a3e19baf8aa1db2ecde4fd12075da0694}} 
\index{Funcdata@{Funcdata}!nodeSplit@{nodeSplit}}
\index{nodeSplit@{nodeSplit}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{nodeSplit()}{nodeSplit()}}
{\footnotesize\ttfamily void Funcdata\+::node\+Split (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classBlockBasic}{Block\+Basic}} $\ast$}]{b,  }\item[{int4}]{inedge }\end{DoxyParamCaption})}



Split control-\/flow into a basic block, duplicating its p-\/code into a new block. 

P-\/code is duplicated into another block, and control-\/flow is modified so that the new block takes over flow from one input edge to the original block. 
\begin{DoxyParams}{Parameters}
{\em b} & is the basic block to be duplicated and split \\
\hline
{\em inedge} & is the index of the input edge to move to the duplicate block \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classFuncdata_a363bd02cb2f20cf1583951d5429a057b}\label{classFuncdata_a363bd02cb2f20cf1583951d5429a057b}} 
\index{Funcdata@{Funcdata}!numHeritagePasses@{numHeritagePasses}}
\index{numHeritagePasses@{numHeritagePasses}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{numHeritagePasses()}{numHeritagePasses()}}
{\footnotesize\ttfamily int4 Funcdata\+::num\+Heritage\+Passes (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classAddrSpace}{Addr\+Space}} $\ast$}]{spc }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Get the number of heritage passes performed for the given address space. 


\begin{DoxyParams}{Parameters}
{\em spc} & is the address space \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the number of passes performed 
\end{DoxyReturn}
\mbox{\Hypertarget{classFuncdata_a07ddc6cd232b4a101968d960fda9b965}\label{classFuncdata_a07ddc6cd232b4a101968d960fda9b965}} 
\index{Funcdata@{Funcdata}!onlyOpUse@{onlyOpUse}}
\index{onlyOpUse@{onlyOpUse}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{onlyOpUse()}{onlyOpUse()}}
{\footnotesize\ttfamily bool Funcdata\+::only\+Op\+Use (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classVarnode}{Varnode}} $\ast$}]{invn,  }\item[{const \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$}]{opmatch,  }\item[{const \mbox{\hyperlink{classParamTrial}{Param\+Trial}} \&}]{trial }\end{DoxyParamCaption}) const}



Test if the given \mbox{\hyperlink{classVarnode}{Varnode}} seems to only be used by a C\+A\+LL. 

Part of testing whether a \mbox{\hyperlink{classVarnode}{Varnode}} makes sense as parameter passing storage is looking for different explicit uses. 
\begin{DoxyParams}{Parameters}
{\em invn} & is the given \mbox{\hyperlink{classVarnode}{Varnode}} \\
\hline
{\em opmatch} & is the putative C\+A\+LL op using the \mbox{\hyperlink{classVarnode}{Varnode}} for parameter passing \\
\hline
{\em trial} & is the parameter trial object associated with the \mbox{\hyperlink{classVarnode}{Varnode}} \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\bfseries{true}} if the \mbox{\hyperlink{classVarnode}{Varnode}} seems only to be used as parameter to {\bfseries{opmatch}} 
\end{DoxyReturn}
\mbox{\Hypertarget{classFuncdata_a6976625d7b40efca0bc9941cb199ee44}\label{classFuncdata_a6976625d7b40efca0bc9941cb199ee44}} 
\index{Funcdata@{Funcdata}!opDestroy@{opDestroy}}
\index{opDestroy@{opDestroy}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{opDestroy()}{opDestroy()}}
{\footnotesize\ttfamily void Funcdata\+::op\+Destroy (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$}]{op }\end{DoxyParamCaption})}



Remove given \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} and destroy its \mbox{\hyperlink{classVarnode}{Varnode}} operands. 

All input and output Varnodes to the op are destroyed (their object resources freed), and the op is permanently moved to the {\itshape dead} list. To call this routine, make sure that either\+:
\begin{DoxyItemize}
\item The op has no output
\item The op\textquotesingle{}s output has no descendants
\item or all descendants of output are also going to be destroyed
\end{DoxyItemize}


\begin{DoxyParams}{Parameters}
{\em op} & is the given \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classFuncdata_aeef2a6be0e9c641f72bf4e87020ddf37}\label{classFuncdata_aeef2a6be0e9c641f72bf4e87020ddf37}} 
\index{Funcdata@{Funcdata}!opDestroyRaw@{opDestroyRaw}}
\index{opDestroyRaw@{opDestroyRaw}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{opDestroyRaw()}{opDestroyRaw()}}
{\footnotesize\ttfamily void Funcdata\+::op\+Destroy\+Raw (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$}]{op }\end{DoxyParamCaption})}



Remove the given {\itshape raw} \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}}. 

This is a specialized routine for deleting an op during flow generation that has been replaced by something else. The op is expected to be {\itshape dead} with none of its inputs or outputs linked to anything else. Both the \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} and all the input/output Varnodes are destroyed. 
\begin{DoxyParams}{Parameters}
{\em op} & is the given \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classFuncdata_a6b77ee6442d79ae754d5dcf0b5318fca}\label{classFuncdata_a6b77ee6442d79ae754d5dcf0b5318fca}} 
\index{Funcdata@{Funcdata}!opInsert@{opInsert}}
\index{opInsert@{opInsert}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{opInsert()}{opInsert()}}
{\footnotesize\ttfamily void Funcdata\+::op\+Insert (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$}]{op,  }\item[{\mbox{\hyperlink{classBlockBasic}{Block\+Basic}} $\ast$}]{bl,  }\item[{list$<$ \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$ $>$\+::iterator}]{iter }\end{DoxyParamCaption})}



Insert the given \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} at specific point in a basic block. 

The \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} is removed from the {\itshape dead} list and is inserted {\itshape immediately} before the specified iterator. 
\begin{DoxyParams}{Parameters}
{\em op} & is the given \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} \\
\hline
{\em bl} & is the basic block being inserted into \\
\hline
{\em iter} & indicates exactly where the op is inserted \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classFuncdata_a3320ad92e11a48a06e21b8a55395a56b}\label{classFuncdata_a3320ad92e11a48a06e21b8a55395a56b}} 
\index{Funcdata@{Funcdata}!opInsertAfter@{opInsertAfter}}
\index{opInsertAfter@{opInsertAfter}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{opInsertAfter()}{opInsertAfter()}}
{\footnotesize\ttfamily void Funcdata\+::op\+Insert\+After (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$}]{op,  }\item[{\mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$}]{prev }\end{DoxyParamCaption})}



Insert given \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} after a specific op. 

The given \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} is inserted {\itshape immediately} after the {\itshape prev} op except\+:
\begin{DoxyItemize}
\item M\+U\+L\+T\+I\+E\+Q\+U\+A\+LS in a basic block all occur first
\item I\+N\+D\+I\+R\+E\+C\+Ts occur immediately before their op
\item a branch op must be the very last op in a basic block
\end{DoxyItemize}


\begin{DoxyParams}{Parameters}
{\em op} & is the given \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} to insert \\
\hline
{\em prev} & is the op to insert after \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classFuncdata_a9dd86e17a47020d06ac8dfd3bb732fe5}\label{classFuncdata_a9dd86e17a47020d06ac8dfd3bb732fe5}} 
\index{Funcdata@{Funcdata}!opInsertBefore@{opInsertBefore}}
\index{opInsertBefore@{opInsertBefore}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{opInsertBefore()}{opInsertBefore()}}
{\footnotesize\ttfamily void Funcdata\+::op\+Insert\+Before (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$}]{op,  }\item[{\mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$}]{follow }\end{DoxyParamCaption})}



Insert given \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} before a specific op. 

The given \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} is inserted {\itshape immediately} before the {\itshape follow} op except\+:
\begin{DoxyItemize}
\item M\+U\+L\+T\+I\+E\+Q\+U\+A\+LS in a basic block all occur first
\item I\+N\+D\+I\+R\+E\+C\+Ts occur immediately before their op
\item a branch op must be the very last op in a basic block
\end{DoxyItemize}


\begin{DoxyParams}{Parameters}
{\em op} & is the given \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} to insert \\
\hline
{\em follow} & is the op to insert before \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classFuncdata_ae6341eb8ca8a8004f1c77a8e8147a286}\label{classFuncdata_ae6341eb8ca8a8004f1c77a8e8147a286}} 
\index{Funcdata@{Funcdata}!opInsertBegin@{opInsertBegin}}
\index{opInsertBegin@{opInsertBegin}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{opInsertBegin()}{opInsertBegin()}}
{\footnotesize\ttfamily void Funcdata\+::op\+Insert\+Begin (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$}]{op,  }\item[{\mbox{\hyperlink{classBlockBasic}{Block\+Basic}} $\ast$}]{bl }\end{DoxyParamCaption})}



Insert given \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} at the beginning of a basic block. 

The given \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} is inserted as the {\itshape first} op in the basic block except\+:
\begin{DoxyItemize}
\item M\+U\+L\+T\+I\+E\+Q\+U\+A\+LS in a basic block all occur first
\item I\+N\+D\+I\+R\+E\+C\+Ts occur immediately before their op
\item a branch op must be the very last op in a basic block
\end{DoxyItemize}


\begin{DoxyParams}{Parameters}
{\em op} & is the given \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} to insert \\
\hline
{\em bl} & is the basic block to insert into \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classFuncdata_ad544a6136ff019bbd18c45043e9b6900}\label{classFuncdata_ad544a6136ff019bbd18c45043e9b6900}} 
\index{Funcdata@{Funcdata}!opInsertEnd@{opInsertEnd}}
\index{opInsertEnd@{opInsertEnd}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{opInsertEnd()}{opInsertEnd()}}
{\footnotesize\ttfamily void Funcdata\+::op\+Insert\+End (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$}]{op,  }\item[{\mbox{\hyperlink{classBlockBasic}{Block\+Basic}} $\ast$}]{bl }\end{DoxyParamCaption})}



Insert given \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} at the end of a basic block. 

The given \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} is inserted as the {\itshape last} op in the basic block except\+:
\begin{DoxyItemize}
\item M\+U\+L\+T\+I\+E\+Q\+U\+A\+LS in a basic block all occur first
\item I\+N\+D\+I\+R\+E\+C\+Ts occur immediately before their op
\item a branch op must be the very last op in a basic block
\end{DoxyItemize}


\begin{DoxyParams}{Parameters}
{\em op} & is the given \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} to insert \\
\hline
{\em bl} & is the basic block to insert into \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classFuncdata_ab34e641f5ee6f2ebf4aa708e21f2b24c}\label{classFuncdata_ab34e641f5ee6f2ebf4aa708e21f2b24c}} 
\index{Funcdata@{Funcdata}!opInsertInput@{opInsertInput}}
\index{opInsertInput@{opInsertInput}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{opInsertInput()}{opInsertInput()}}
{\footnotesize\ttfamily void Funcdata\+::op\+Insert\+Input (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$}]{op,  }\item[{\mbox{\hyperlink{classVarnode}{Varnode}} $\ast$}]{vn,  }\item[{int4}]{slot }\end{DoxyParamCaption})}



Insert a new \mbox{\hyperlink{classVarnode}{Varnode}} into the operand list for the given \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}}. 

The given \mbox{\hyperlink{classVarnode}{Varnode}} is set into the given operand slot. Any existing input Varnodes with slot indices equal to or greater than the specified slot are pushed into the next slot. 
\begin{DoxyParams}{Parameters}
{\em op} & is the given \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} \\
\hline
{\em vn} & is the given \mbox{\hyperlink{classVarnode}{Varnode}} to insert \\
\hline
{\em slot} & is the input index to insert at \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classFuncdata_acdbfab2362e4d4945c3feb7d3f2c42f2}\label{classFuncdata_acdbfab2362e4d4945c3feb7d3f2c42f2}} 
\index{Funcdata@{Funcdata}!opMarkHalt@{opMarkHalt}}
\index{opMarkHalt@{opMarkHalt}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{opMarkHalt()}{opMarkHalt()}}
{\footnotesize\ttfamily void Funcdata\+::op\+Mark\+Halt (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$}]{op,  }\item[{uint4}]{flag }\end{DoxyParamCaption})}



Mark given C\+P\+U\+I\+\_\+\+R\+E\+T\+U\+RN op as a {\itshape special} halt. 


\begin{DoxyParams}{Parameters}
{\em op} & is the given C\+P\+U\+I\+\_\+\+R\+E\+T\+U\+RN op \\
\hline
{\em flag} & is one of {\itshape halt}, {\itshape badinstruction}, {\itshape unimplemented}, {\itshape noreturn}, or {\itshape missing}. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classFuncdata_a84937c2241ea5679280223cc0ec8b202}\label{classFuncdata_a84937c2241ea5679280223cc0ec8b202}} 
\index{Funcdata@{Funcdata}!opRemoveInput@{opRemoveInput}}
\index{opRemoveInput@{opRemoveInput}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{opRemoveInput()}{opRemoveInput()}}
{\footnotesize\ttfamily void Funcdata\+::op\+Remove\+Input (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$}]{op,  }\item[{int4}]{slot }\end{DoxyParamCaption})}



Remove a specific input slot for the given \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}}. 

The \mbox{\hyperlink{classVarnode}{Varnode}} in the specified slot is unlinked from the op and the slot itself is removed. The slot index for any remaining input Varnodes coming after the specified slot is decreased by one. 
\begin{DoxyParams}{Parameters}
{\em op} & is the given \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} \\
\hline
{\em slot} & is the index of the specified slot to remove \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classFuncdata_adcad3bfd56955103a031fa6d0e78acec}\label{classFuncdata_adcad3bfd56955103a031fa6d0e78acec}} 
\index{Funcdata@{Funcdata}!opSetAllInput@{opSetAllInput}}
\index{opSetAllInput@{opSetAllInput}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{opSetAllInput()}{opSetAllInput()}}
{\footnotesize\ttfamily void Funcdata\+::op\+Set\+All\+Input (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$}]{op,  }\item[{const vector$<$ \mbox{\hyperlink{classVarnode}{Varnode}} $\ast$ $>$ \&}]{vvec }\end{DoxyParamCaption})}



Set all input Varnodes for the given \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} simultaneously. 

All previously existing input Varnodes are unset. The input slots for the op are resized and then filled in from the specified array. 
\begin{DoxyParams}{Parameters}
{\em op} & is the given \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} to set \\
\hline
{\em vvec} & is the specified array of new input Varnodes \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classFuncdata_aa079e2bd26e92671be79601535236a63}\label{classFuncdata_aa079e2bd26e92671be79601535236a63}} 
\index{Funcdata@{Funcdata}!opSetInput@{opSetInput}}
\index{opSetInput@{opSetInput}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{opSetInput()}{opSetInput()}}
{\footnotesize\ttfamily void Funcdata\+::op\+Set\+Input (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$}]{op,  }\item[{\mbox{\hyperlink{classVarnode}{Varnode}} $\ast$}]{vn,  }\item[{int4}]{slot }\end{DoxyParamCaption})}



Set a specific input operand for the given \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}}. 


\begin{DoxyParams}{Parameters}
{\em op} & is the given \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} \\
\hline
{\em vn} & is the operand \mbox{\hyperlink{classVarnode}{Varnode}} to set \\
\hline
{\em slot} & is the input slot where the \mbox{\hyperlink{classVarnode}{Varnode}} is placed \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classFuncdata_ad9dbf52668db4a1923537e2128719181}\label{classFuncdata_ad9dbf52668db4a1923537e2128719181}} 
\index{Funcdata@{Funcdata}!opSetOpcode@{opSetOpcode}}
\index{opSetOpcode@{opSetOpcode}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{opSetOpcode()}{opSetOpcode()}}
{\footnotesize\ttfamily void Funcdata\+::op\+Set\+Opcode (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$}]{op,  }\item[{\mbox{\hyperlink{opcodes_8hh_abeb7dfb0e9e2b3114e240a405d046ea7}{Op\+Code}}}]{opc }\end{DoxyParamCaption})}



Set the op-\/code for a specific \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}}. 


\begin{DoxyParams}{Parameters}
{\em op} & is the given \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} \\
\hline
{\em opc} & is the op-\/code to set \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classFuncdata_ab2bd3523c574c5b303728ef4d880ec3a}\label{classFuncdata_ab2bd3523c574c5b303728ef4d880ec3a}} 
\index{Funcdata@{Funcdata}!opSetOutput@{opSetOutput}}
\index{opSetOutput@{opSetOutput}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{opSetOutput()}{opSetOutput()}}
{\footnotesize\ttfamily void Funcdata\+::op\+Set\+Output (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$}]{op,  }\item[{\mbox{\hyperlink{classVarnode}{Varnode}} $\ast$}]{vn }\end{DoxyParamCaption})}



Set a specific output \mbox{\hyperlink{classVarnode}{Varnode}} for the given \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}}. 


\begin{DoxyParams}{Parameters}
{\em op} & is the specific \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} \\
\hline
{\em vn} & is the output \mbox{\hyperlink{classVarnode}{Varnode}} to set \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classFuncdata_a37b36505bab6f7c5676157288e65d5c6}\label{classFuncdata_a37b36505bab6f7c5676157288e65d5c6}} 
\index{Funcdata@{Funcdata}!opStackLoad@{opStackLoad}}
\index{opStackLoad@{opStackLoad}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{opStackLoad()}{opStackLoad()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classVarnode}{Varnode}} $\ast$ Funcdata\+::op\+Stack\+Load (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classAddrSpace}{Addr\+Space}} $\ast$}]{spc,  }\item[{uintb}]{off,  }\item[{uint4}]{sz,  }\item[{\mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$}]{op,  }\item[{\mbox{\hyperlink{classVarnode}{Varnode}} $\ast$}]{stackref,  }\item[{bool}]{insertafter }\end{DoxyParamCaption})}



Create a L\+O\+AD expression at an offset relative to a {\itshape spacebase} register for a given address space. 

The {\itshape spacebase} register is looked up for the given address space, or an optional previously existing register \mbox{\hyperlink{classVarnode}{Varnode}} can be provided. An insertion point op must be provided, and newly generated ops can come either before or after this insertion point. 
\begin{DoxyParams}{Parameters}
{\em spc} & is the given address space \\
\hline
{\em off} & is the offset to calculate relative to the {\itshape spacebase} register \\
\hline
{\em sz} & is the size of the desire L\+O\+AD in bytes \\
\hline
{\em op} & is the insertion point \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} \\
\hline
{\em stackref} & is the {\itshape spacebase} register \mbox{\hyperlink{classVarnode}{Varnode}} (if available) \\
\hline
{\em insertafter} & is {\bfseries{true}} if new ops are inserted {\itshape after} the insertion point \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the {\itshape unique} space \mbox{\hyperlink{classVarnode}{Varnode}} holding the result of the L\+O\+AD 
\end{DoxyReturn}
\mbox{\Hypertarget{classFuncdata_a4582ad34b4e7c851d92db8544999eaf3}\label{classFuncdata_a4582ad34b4e7c851d92db8544999eaf3}} 
\index{Funcdata@{Funcdata}!opStackStore@{opStackStore}}
\index{opStackStore@{opStackStore}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{opStackStore()}{opStackStore()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$ Funcdata\+::op\+Stack\+Store (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classAddrSpace}{Addr\+Space}} $\ast$}]{spc,  }\item[{uintb}]{off,  }\item[{\mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$}]{op,  }\item[{bool}]{insertafter }\end{DoxyParamCaption})}



Create a S\+T\+O\+RE expression at an offset relative to a {\itshape spacebase} register for a given address space. 

The {\itshape spacebase} register is looked up for the given address space. An insertion point op must be provided, and newly generated ops can come either before or after this insertion point. The \mbox{\hyperlink{classVarnode}{Varnode}} value being stored must still be set on the returned \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}}. 
\begin{DoxyParams}{Parameters}
{\em spc} & is the given address space \\
\hline
{\em off} & is the offset to calculate relative to the {\itshape spacebase} register \\
\hline
{\em op} & is the insertion point \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} \\
\hline
{\em insertafter} & is {\bfseries{true}} if new ops are inserted {\itshape after} the insertion point \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the S\+T\+O\+RE \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} 
\end{DoxyReturn}
\mbox{\Hypertarget{classFuncdata_a1ae30fdfbe33ecfa6668b5579ae3e82a}\label{classFuncdata_a1ae30fdfbe33ecfa6668b5579ae3e82a}} 
\index{Funcdata@{Funcdata}!opSwapInput@{opSwapInput}}
\index{opSwapInput@{opSwapInput}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{opSwapInput()}{opSwapInput()}}
{\footnotesize\ttfamily void Funcdata\+::op\+Swap\+Input (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$}]{op,  }\item[{int4}]{slot1,  }\item[{int4}]{slot2 }\end{DoxyParamCaption})}



Swap two input operands in the given \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}}. 

This is convenience method that is more efficient than call \mbox{\hyperlink{classFuncdata_aa079e2bd26e92671be79601535236a63}{op\+Set\+Input()}} twice. 
\begin{DoxyParams}{Parameters}
{\em op} & is the given \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} \\
\hline
{\em slot1} & is the first input slot being switched \\
\hline
{\em slot2} & is the second input slot \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classFuncdata_ad74d3baa2516f448e7ab5f9a8151b572}\label{classFuncdata_ad74d3baa2516f448e7ab5f9a8151b572}} 
\index{Funcdata@{Funcdata}!opUndoPtradd@{opUndoPtradd}}
\index{opUndoPtradd@{opUndoPtradd}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{opUndoPtradd()}{opUndoPtradd()}}
{\footnotesize\ttfamily void Funcdata\+::op\+Undo\+Ptradd (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$}]{op,  }\item[{bool}]{finalize }\end{DoxyParamCaption})}



Convert a C\+P\+U\+I\+\_\+\+P\+T\+R\+A\+DD back into a C\+P\+U\+I\+\_\+\+I\+N\+T\+\_\+\+A\+DD. 

Convert the given C\+P\+U\+I\+\_\+\+P\+T\+R\+A\+DD into the equivalent C\+P\+U\+I\+\_\+\+I\+N\+T\+\_\+\+A\+DD. This may involve inserting a C\+P\+U\+I\+\_\+\+I\+N\+T\+\_\+\+M\+U\+LT \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}}. If finalization is requested and a new \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} is needed, the output \mbox{\hyperlink{classVarnode}{Varnode}} is marked as {\itshape implicit} and has its data-\/type set 
\begin{DoxyParams}{Parameters}
{\em op} & is the given P\+T\+R\+A\+DD \\
\hline
{\em finalize} & is {\bfseries{true}} if finalization is needed for any new \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classFuncdata_aacf0cf87976170d62df42411ffe1e10a}\label{classFuncdata_aacf0cf87976170d62df42411ffe1e10a}} 
\index{Funcdata@{Funcdata}!opUninsert@{opUninsert}}
\index{opUninsert@{opUninsert}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{opUninsert()}{opUninsert()}}
{\footnotesize\ttfamily void Funcdata\+::op\+Uninsert (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$}]{op }\end{DoxyParamCaption})}



Remove the given \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} from its basic block. 

The op is taken out of its basic block and put into the dead list. If the removal is permanent the input and output Varnodes should be unset. 
\begin{DoxyParams}{Parameters}
{\em op} & is the given \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classFuncdata_a495ebac694bc98d041e29ce05eece6f9}\label{classFuncdata_a495ebac694bc98d041e29ce05eece6f9}} 
\index{Funcdata@{Funcdata}!opUnlink@{opUnlink}}
\index{opUnlink@{opUnlink}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{opUnlink()}{opUnlink()}}
{\footnotesize\ttfamily void Funcdata\+::op\+Unlink (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$}]{op }\end{DoxyParamCaption})}



Unset inputs/output and remove given Pcode\+OP from its basic block. 

The op is extricated from all its \mbox{\hyperlink{classVarnode}{Varnode}} connections to the functions data-\/flow and removed from its basic block. This will {\itshape not} change block connections. The \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} objects remains in the {\itshape dead} list. 
\begin{DoxyParams}{Parameters}
{\em op} & is the given \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classFuncdata_a16f821f09d862b3c908d2bce7530b90a}\label{classFuncdata_a16f821f09d862b3c908d2bce7530b90a}} 
\index{Funcdata@{Funcdata}!opUnsetInput@{opUnsetInput}}
\index{opUnsetInput@{opUnsetInput}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{opUnsetInput()}{opUnsetInput()}}
{\footnotesize\ttfamily void Funcdata\+::op\+Unset\+Input (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$}]{op,  }\item[{int4}]{slot }\end{DoxyParamCaption})}



Clear an input operand slot for the given \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}}. 

The input \mbox{\hyperlink{classVarnode}{Varnode}} is unlinked from the op. 
\begin{DoxyParams}{Parameters}
{\em op} & is the given \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} \\
\hline
{\em slot} & is the input slot to clear \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classFuncdata_ab91b54da6501e12d4ad1e81ab5d0e5c4}\label{classFuncdata_ab91b54da6501e12d4ad1e81ab5d0e5c4}} 
\index{Funcdata@{Funcdata}!opUnsetOutput@{opUnsetOutput}}
\index{opUnsetOutput@{opUnsetOutput}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{opUnsetOutput()}{opUnsetOutput()}}
{\footnotesize\ttfamily void Funcdata\+::op\+Unset\+Output (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$}]{op }\end{DoxyParamCaption})}



Remove output \mbox{\hyperlink{classVarnode}{Varnode}} from the given \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}}. 

The output \mbox{\hyperlink{classVarnode}{Varnode}} becomes {\itshape free} but is not immediately deleted. 
\begin{DoxyParams}{Parameters}
{\em op} & is the given \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classFuncdata_aafb83719ca201b5d57283058e2bcadee}\label{classFuncdata_aafb83719ca201b5d57283058e2bcadee}} 
\index{Funcdata@{Funcdata}!overrideFlow@{overrideFlow}}
\index{overrideFlow@{overrideFlow}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{overrideFlow()}{overrideFlow()}}
{\footnotesize\ttfamily void Funcdata\+::override\+Flow (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classAddress}{Address}} \&}]{addr,  }\item[{uint4}]{type }\end{DoxyParamCaption})}



\mbox{\hyperlink{classOverride}{Override}} the control-\/flow p-\/code for a particular instruction. 

P-\/code in {\bfseries{this}} function is modified to change the control-\/flow of the instruction at the given address, based on the \mbox{\hyperlink{classOverride}{Override}} type. 
\begin{DoxyParams}{Parameters}
{\em addr} & is the given address of the instruction to modify \\
\hline
{\em type} & is the \mbox{\hyperlink{classOverride}{Override}} type \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classFuncdata_a8c86861b22f4beb1cac5ab3ab43db6ae}\label{classFuncdata_a8c86861b22f4beb1cac5ab3ab43db6ae}} 
\index{Funcdata@{Funcdata}!printBlockTree@{printBlockTree}}
\index{printBlockTree@{printBlockTree}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{printBlockTree()}{printBlockTree()}}
{\footnotesize\ttfamily void Funcdata\+::print\+Block\+Tree (\begin{DoxyParamCaption}\item[{ostream \&}]{s }\end{DoxyParamCaption}) const}



Print a description of control-\/flow structuring to a stream. 

A description of each block in the current structure hierarchy is printed to stream. This is suitable for a console mode or debug view of the state of control-\/flow structuring at any point during analysis. 
\begin{DoxyParams}{Parameters}
{\em s} & is the output stream \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classFuncdata_a2b52d8ec8b53529b02881977971067ce}\label{classFuncdata_a2b52d8ec8b53529b02881977971067ce}} 
\index{Funcdata@{Funcdata}!printLocalRange@{printLocalRange}}
\index{printLocalRange@{printLocalRange}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{printLocalRange()}{printLocalRange()}}
{\footnotesize\ttfamily void Funcdata\+::print\+Local\+Range (\begin{DoxyParamCaption}\item[{ostream \&}]{s }\end{DoxyParamCaption}) const}



Print description of memory ranges associated with local scopes. 

Each scope has a set of memory ranges associated with it, encompassing storage locations of variables that are {\itshape assumed} to be in the scope. Each range for each local scope is printed. 
\begin{DoxyParams}{Parameters}
{\em s} & is the output stream \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classFuncdata_a9a3cdbf385c382c10fc5b48f5842b418}\label{classFuncdata_a9a3cdbf385c382c10fc5b48f5842b418}} 
\index{Funcdata@{Funcdata}!printRaw@{printRaw}}
\index{printRaw@{printRaw}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{printRaw()}{printRaw()}}
{\footnotesize\ttfamily void Funcdata\+::print\+Raw (\begin{DoxyParamCaption}\item[{ostream \&}]{s }\end{DoxyParamCaption}) const}



Print raw p-\/code op descriptions to a stream. 

A representation of all Pcode\+Ops in the function body are printed to the stream. Depending on the state of analysis, Pcode\+Ops are grouped into their basic blocks, and within a block, ops are displayed sequentially. Basic labeling of branch destinations is also printed. This is suitable for a console mode or debug view of the state of the function at any given point in its analysis. 
\begin{DoxyParams}{Parameters}
{\em s} & is the output stream \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classFuncdata_ac150948163b641a4d138ef82bf213f4e}\label{classFuncdata_ac150948163b641a4d138ef82bf213f4e}} 
\index{Funcdata@{Funcdata}!printVarnodeTree@{printVarnodeTree}}
\index{printVarnodeTree@{printVarnodeTree}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{printVarnodeTree()}{printVarnodeTree()}}
{\footnotesize\ttfamily void Funcdata\+::print\+Varnode\+Tree (\begin{DoxyParamCaption}\item[{ostream \&}]{s }\end{DoxyParamCaption}) const}



Print a description of all Varnodes to a stream. 

A description of each \mbox{\hyperlink{classVarnode}{Varnode}} currently involved in the data-\/flow of {\bfseries{this}} function is printed to the output stream. This is suitable as part of a console mode or debug view of the function at any point during its analysis 
\begin{DoxyParams}{Parameters}
{\em s} & is the output stream \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classFuncdata_aa2d635570305e3ea710ade3cf090ba8c}\label{classFuncdata_aa2d635570305e3ea710ade3cf090ba8c}} 
\index{Funcdata@{Funcdata}!pushBranch@{pushBranch}}
\index{pushBranch@{pushBranch}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{pushBranch()}{pushBranch()}}
{\footnotesize\ttfamily void Funcdata\+::push\+Branch (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classBlockBasic}{Block\+Basic}} $\ast$}]{bb,  }\item[{int4}]{slot,  }\item[{\mbox{\hyperlink{classBlockBasic}{Block\+Basic}} $\ast$}]{bbnew }\end{DoxyParamCaption})}



Move a control-\/flow edge from one block to another. 

This is intended for eliminating switch guard artifacts. The edge must be for a conditional jump and must be moved to a block hosting multiple out edges for a B\+R\+A\+N\+C\+H\+I\+ND. 
\begin{DoxyParams}{Parameters}
{\em bb} & is the basic block out of which the edge to move flows \\
\hline
{\em slot} & is the index of the (out) edge \\
\hline
{\em bbnew} & is the basic block where the edge should get moved to \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classFuncdata_a38d58c33cdc77c663fceb7de1f6aadeb}\label{classFuncdata_a38d58c33cdc77c663fceb7de1f6aadeb}} 
\index{Funcdata@{Funcdata}!recoverJumpTable@{recoverJumpTable}}
\index{recoverJumpTable@{recoverJumpTable}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{recoverJumpTable()}{recoverJumpTable()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classJumpTable}{Jump\+Table}} $\ast$ Funcdata\+::recover\+Jump\+Table (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$}]{op,  }\item[{\mbox{\hyperlink{classFlowInfo}{Flow\+Info}} $\ast$}]{flow,  }\item[{int4 \&}]{failuremode }\end{DoxyParamCaption})}



Recover destinations for a B\+R\+A\+N\+C\+H\+I\+ND by analyzing nearby data and control-\/flow. 

This is the high-\/level entry point for jump-\/table/switch recovery. In short, a copy of the current state of data-\/flow is made, simplification transformations are applied to the copy, and the resulting data-\/flow tree is examined to enumerate possible values of the input \mbox{\hyperlink{classVarnode}{Varnode}} to the given B\+R\+A\+N\+C\+H\+I\+ND \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}}. This information is stored in a \mbox{\hyperlink{classJumpTable}{Jump\+Table}} object. 
\begin{DoxyParams}{Parameters}
{\em op} & is the given B\+R\+A\+N\+C\+H\+I\+ND \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} \\
\hline
{\em flow} & is current flow information for {\bfseries{this}} function \\
\hline
{\em failuremode} & will hold the final success/failure code (0=success) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the recovered \mbox{\hyperlink{classJumpTable}{Jump\+Table}} or N\+U\+LL if there was no success 
\end{DoxyReturn}
\mbox{\Hypertarget{classFuncdata_a73cbb6375e48cddaedf5e55e40119c84}\label{classFuncdata_a73cbb6375e48cddaedf5e55e40119c84}} 
\index{Funcdata@{Funcdata}!remapDynamicVarnode@{remapDynamicVarnode}}
\index{remapDynamicVarnode@{remapDynamicVarnode}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{remapDynamicVarnode()}{remapDynamicVarnode()}}
{\footnotesize\ttfamily void Funcdata\+::remap\+Dynamic\+Varnode (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classVarnode}{Varnode}} $\ast$}]{vn,  }\item[{\mbox{\hyperlink{classSymbol}{Symbol}} $\ast$}]{sym,  }\item[{const \mbox{\hyperlink{classAddress}{Address}} \&}]{usepoint,  }\item[{uint8}]{hash }\end{DoxyParamCaption})}



Remap a \mbox{\hyperlink{classSymbol}{Symbol}} to a given \mbox{\hyperlink{classVarnode}{Varnode}} using a new dynamic mapping. 

Any previous links between the \mbox{\hyperlink{classSymbol}{Symbol}}, the \mbox{\hyperlink{classVarnode}{Varnode}}, and the associate \mbox{\hyperlink{classHighVariable}{High\+Variable}} are removed. Then a new dynamic link is created. 
\begin{DoxyParams}{Parameters}
{\em vn} & is the given \mbox{\hyperlink{classVarnode}{Varnode}} \\
\hline
{\em sym} & is the \mbox{\hyperlink{classSymbol}{Symbol}} the \mbox{\hyperlink{classVarnode}{Varnode}} maps to \\
\hline
{\em usepoint} & is the code \mbox{\hyperlink{classAddress}{Address}} where the \mbox{\hyperlink{classVarnode}{Varnode}} is defined \\
\hline
{\em hash} & is the hash for the new dynamic mapping \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classFuncdata_a6145d643e13a072975e34255a06f4e84}\label{classFuncdata_a6145d643e13a072975e34255a06f4e84}} 
\index{Funcdata@{Funcdata}!remapVarnode@{remapVarnode}}
\index{remapVarnode@{remapVarnode}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{remapVarnode()}{remapVarnode()}}
{\footnotesize\ttfamily void Funcdata\+::remap\+Varnode (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classVarnode}{Varnode}} $\ast$}]{vn,  }\item[{\mbox{\hyperlink{classSymbol}{Symbol}} $\ast$}]{sym,  }\item[{const \mbox{\hyperlink{classAddress}{Address}} \&}]{usepoint }\end{DoxyParamCaption})}



Remap a \mbox{\hyperlink{classSymbol}{Symbol}} to a given \mbox{\hyperlink{classVarnode}{Varnode}} using a static mapping. 

Any previous links between the \mbox{\hyperlink{classSymbol}{Symbol}}, the \mbox{\hyperlink{classVarnode}{Varnode}}, and the associate \mbox{\hyperlink{classHighVariable}{High\+Variable}} are removed. Then a new link is created. 
\begin{DoxyParams}{Parameters}
{\em vn} & is the given \mbox{\hyperlink{classVarnode}{Varnode}} \\
\hline
{\em sym} & is the \mbox{\hyperlink{classSymbol}{Symbol}} the \mbox{\hyperlink{classVarnode}{Varnode}} maps to \\
\hline
{\em usepoint} & is the desired usepoint for the mapping \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classFuncdata_a3a53162bf9a1756c4f2f4d7d1d7bbcec}\label{classFuncdata_a3a53162bf9a1756c4f2f4d7d1d7bbcec}} 
\index{Funcdata@{Funcdata}!removeBranch@{removeBranch}}
\index{removeBranch@{removeBranch}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{removeBranch()}{removeBranch()}}
{\footnotesize\ttfamily void Funcdata\+::remove\+Branch (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classBlockBasic}{Block\+Basic}} $\ast$}]{bb,  }\item[{int4}]{num }\end{DoxyParamCaption})}



Remove the indicated branch from a basic block. 

The edge is removed from control-\/flow and affected M\+U\+L\+T\+I\+E\+Q\+U\+AL ops are adjusted. 
\begin{DoxyParams}{Parameters}
{\em bb} & is the basic block \\
\hline
{\em num} & is the index of the out edge to remove \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classFuncdata_aa486c5f0556919686a9fdad4ebc2dcc1}\label{classFuncdata_aa486c5f0556919686a9fdad4ebc2dcc1}} 
\index{Funcdata@{Funcdata}!removeDoNothingBlock@{removeDoNothingBlock}}
\index{removeDoNothingBlock@{removeDoNothingBlock}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{removeDoNothingBlock()}{removeDoNothingBlock()}}
{\footnotesize\ttfamily void Funcdata\+::remove\+Do\+Nothing\+Block (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classBlockBasic}{Block\+Basic}} $\ast$}]{bb }\end{DoxyParamCaption})}



Remove a basic block from control-\/flow that performs no operations. 

The block must contain only {\itshape marker} operations (M\+U\+L\+T\+I\+E\+Q\+U\+AL) and possibly a single unconditional branch operation. The block and its Pcode\+Ops are completely removed from the current control-\/flow and data-\/flow. This forces a reset of the control-\/flow structuring hierarchy. 
\begin{DoxyParams}{Parameters}
{\em bb} & is the given basic block \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classFuncdata_af83619924b5d0fed25d0563b0f243262}\label{classFuncdata_af83619924b5d0fed25d0563b0f243262}} 
\index{Funcdata@{Funcdata}!removeFromFlowSplit@{removeFromFlowSplit}}
\index{removeFromFlowSplit@{removeFromFlowSplit}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{removeFromFlowSplit()}{removeFromFlowSplit()}}
{\footnotesize\ttfamily void Funcdata\+::remove\+From\+Flow\+Split (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classBlockBasic}{Block\+Basic}} $\ast$}]{bl,  }\item[{bool}]{swap }\end{DoxyParamCaption})}



Remove a basic block splitting its control-\/flow into two distinct paths. 

This is used by \mbox{\hyperlink{classConditionalExecution}{Conditional\+Execution}} to eliminate unnecessary control-\/flow joins. The given block must have 2 inputs and 2 outputs, (and no operations). The block is removed, and control-\/flow is adjusted so that In(0) flows to Out(0) and In(1) flows to Out(1), or vice versa. 
\begin{DoxyParams}{Parameters}
{\em bl} & is the given basic block \\
\hline
{\em swap} & is {\bfseries{true}} to force In(0)-\/$>$Out(1) and In(1)-\/$>$Out(0) \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classFuncdata_a2e75df713649c7bba52b17b1b84bbcf6}\label{classFuncdata_a2e75df713649c7bba52b17b1b84bbcf6}} 
\index{Funcdata@{Funcdata}!removeJumpTable@{removeJumpTable}}
\index{removeJumpTable@{removeJumpTable}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{removeJumpTable()}{removeJumpTable()}}
{\footnotesize\ttfamily void Funcdata\+::remove\+Jump\+Table (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classJumpTable}{Jump\+Table}} $\ast$}]{jt }\end{DoxyParamCaption})}



Remove/delete the given jump-\/table. 

The \mbox{\hyperlink{classJumpTable}{Jump\+Table}} object is freed, and the associated B\+R\+A\+N\+C\+H\+I\+ND is no longer marked as a {\itshape switch} point. 
\begin{DoxyParams}{Parameters}
{\em jt} & is the given \mbox{\hyperlink{classJumpTable}{Jump\+Table}} object \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classFuncdata_a0fca3088c3d01a584aef0db49dfccc63}\label{classFuncdata_a0fca3088c3d01a584aef0db49dfccc63}} 
\index{Funcdata@{Funcdata}!removeUnreachableBlocks@{removeUnreachableBlocks}}
\index{removeUnreachableBlocks@{removeUnreachableBlocks}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{removeUnreachableBlocks()}{removeUnreachableBlocks()}}
{\footnotesize\ttfamily bool Funcdata\+::remove\+Unreachable\+Blocks (\begin{DoxyParamCaption}\item[{bool}]{issuewarning,  }\item[{bool}]{checkexistence }\end{DoxyParamCaption})}



Remove any unreachable basic blocks. 

A quick check for unreachable blocks can optionally be made, otherwise the cached state is checked via has\+Unreachable\+Blocks(), which is turned on during analysis by calling the structure\+Reset() method. 
\begin{DoxyParams}{Parameters}
{\em issuewarning} & is {\bfseries{true}} if warning comments are desired \\
\hline
{\em checkexistence} & is {\bfseries{true}} to force an active search for unreachable blocks \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\bfseries{true}} if unreachable blocks were actually found and removed 
\end{DoxyReturn}
\mbox{\Hypertarget{classFuncdata_a223a70ddb5e33f446fca85bc3b369911}\label{classFuncdata_a223a70ddb5e33f446fca85bc3b369911}} 
\index{Funcdata@{Funcdata}!replaceLessequal@{replaceLessequal}}
\index{replaceLessequal@{replaceLessequal}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{replaceLessequal()}{replaceLessequal()}}
{\footnotesize\ttfamily bool Funcdata\+::replace\+Lessequal (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$}]{op }\end{DoxyParamCaption})}



Replace I\+N\+T\+\_\+\+L\+E\+S\+S\+E\+Q\+U\+AL and I\+N\+T\+\_\+\+S\+L\+E\+S\+S\+E\+Q\+U\+AL expressions. 

Do in-\/place replacement of
\begin{DoxyItemize}
\item {\ttfamily c $<$= x} with {\ttfamily c-\/1 $<$ x} OR
\item {\ttfamily x $<$= c} with {\ttfamily x $<$ c+1}
\end{DoxyItemize}


\begin{DoxyParams}{Parameters}
{\em op} & is comparison \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if a valid replacement was performed 
\end{DoxyReturn}
\mbox{\Hypertarget{classFuncdata_a754fe8bd5805e6d9fd8041365e7747eb}\label{classFuncdata_a754fe8bd5805e6d9fd8041365e7747eb}} 
\index{Funcdata@{Funcdata}!replaceVolatile@{replaceVolatile}}
\index{replaceVolatile@{replaceVolatile}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{replaceVolatile()}{replaceVolatile()}}
{\footnotesize\ttfamily bool Funcdata\+::replace\+Volatile (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classVarnode}{Varnode}} $\ast$}]{vn }\end{DoxyParamCaption})}



Replace accesses of the given \mbox{\hyperlink{classVarnode}{Varnode}} with {\itshape volatile} operations. 

The \mbox{\hyperlink{classVarnode}{Varnode}} is assumed not fully linked. The read or write action is modeled by inserting a special {\itshape user} op that represents the action. The given \mbox{\hyperlink{classVarnode}{Varnode}} is replaced by a temporary \mbox{\hyperlink{classVarnode}{Varnode}} within the data-\/flow, and the original address becomes a parameter to the user op. 
\begin{DoxyParams}{Parameters}
{\em vn} & is the given \mbox{\hyperlink{classVarnode}{Varnode}} to model as volatile \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\bfseries{true}} if a change was made 
\end{DoxyReturn}
\mbox{\Hypertarget{classFuncdata_a7419de8057421b8e9300c4a26c60ecef}\label{classFuncdata_a7419de8057421b8e9300c4a26c60ecef}} 
\index{Funcdata@{Funcdata}!restoreXml@{restoreXml}}
\index{restoreXml@{restoreXml}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{restoreXml()}{restoreXml()}}
{\footnotesize\ttfamily uint8 Funcdata\+::restore\+Xml (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classElement}{Element}} $\ast$}]{el }\end{DoxyParamCaption})}



Restore the state of {\bfseries{this}} function from an X\+ML description. 

From an X\+ML $<$function$>$ tag, recover the name, address, prototype, symbol, jump-\/table, and override information for {\bfseries{this}} function. 
\begin{DoxyParams}{Parameters}
{\em el} & is the root $<$function$>$ tag \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the symbol id associated with the function 
\end{DoxyReturn}
\mbox{\Hypertarget{classFuncdata_a07a41bb91dd51c9a76d8f6d1e2f09328}\label{classFuncdata_a07a41bb91dd51c9a76d8f6d1e2f09328}} 
\index{Funcdata@{Funcdata}!restoreXmlJumpTable@{restoreXmlJumpTable}}
\index{restoreXmlJumpTable@{restoreXmlJumpTable}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{restoreXmlJumpTable()}{restoreXmlJumpTable()}}
{\footnotesize\ttfamily void Funcdata\+::restore\+Xml\+Jump\+Table (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classElement}{Element}} $\ast$}]{el }\end{DoxyParamCaption})}



Restore jump-\/tables from an X\+ML description. 

This parses a $<$jumptablelist$>$ tag and builds a \mbox{\hyperlink{classJumpTable}{Jump\+Table}} object for each $<$jumptable$>$ sub-\/tag. 
\begin{DoxyParams}{Parameters}
{\em el} & is the root $<$jumptablelist$>$ tag \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classFuncdata_ac8e7664bd70368066f7ad70a8922795e}\label{classFuncdata_ac8e7664bd70368066f7ad70a8922795e}} 
\index{Funcdata@{Funcdata}!saveXml@{saveXml}}
\index{saveXml@{saveXml}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{saveXml()}{saveXml()}}
{\footnotesize\ttfamily void Funcdata\+::save\+Xml (\begin{DoxyParamCaption}\item[{ostream \&}]{s,  }\item[{uint8}]{id,  }\item[{bool}]{savetree }\end{DoxyParamCaption}) const}



Emit an X\+ML description of {\bfseries{this}} function to stream. 

An X\+ML description of {\bfseries{this}} function is written to the stream, including name, address, prototype, symbol, jump-\/table, and override information. If indicated by the caller, a description of the entire \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} and \mbox{\hyperlink{classVarnode}{Varnode}} tree is also emitted. 
\begin{DoxyParams}{Parameters}
{\em s} & is the output stream \\
\hline
{\em id} & is the unique id associated with the function symbol \\
\hline
{\em savetree} & is {\bfseries{true}} if the p-\/code tree should be emitted \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classFuncdata_accde64f2642f6e86545df826e2751f8b}\label{classFuncdata_accde64f2642f6e86545df826e2751f8b}} 
\index{Funcdata@{Funcdata}!saveXmlHigh@{saveXmlHigh}}
\index{saveXmlHigh@{saveXmlHigh}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{saveXmlHigh()}{saveXmlHigh()}}
{\footnotesize\ttfamily void Funcdata\+::save\+Xml\+High (\begin{DoxyParamCaption}\item[{ostream \&}]{s }\end{DoxyParamCaption}) const}



Save an X\+ML description of all High\+Variables to stream. 

This produces a single $<$highlist$>$ tag, with a $<$high$>$ sub-\/tag for each high-\/level variable (\mbox{\hyperlink{classHighVariable}{High\+Variable}}) currently associated with {\bfseries{this}} function. 
\begin{DoxyParams}{Parameters}
{\em s} & is the output stream \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classFuncdata_a5f2d5d66f0ae7c5c4eae20d60ad30897}\label{classFuncdata_a5f2d5d66f0ae7c5c4eae20d60ad30897}} 
\index{Funcdata@{Funcdata}!saveXmlJumpTable@{saveXmlJumpTable}}
\index{saveXmlJumpTable@{saveXmlJumpTable}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{saveXmlJumpTable()}{saveXmlJumpTable()}}
{\footnotesize\ttfamily void Funcdata\+::save\+Xml\+Jump\+Table (\begin{DoxyParamCaption}\item[{ostream \&}]{s }\end{DoxyParamCaption}) const}



Emit an X\+ML description of jump-\/tables to stream. 

A $<$jumptablelist$>$ tag is written with $<$jumptable$>$ sub-\/tags describing each jump-\/table associated with the control-\/flow of {\bfseries{this}} function. 
\begin{DoxyParams}{Parameters}
{\em s} & is the output stream \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classFuncdata_a7630153130424a56fac5a4b4a4792b60}\label{classFuncdata_a7630153130424a56fac5a4b4a4792b60}} 
\index{Funcdata@{Funcdata}!saveXmlTree@{saveXmlTree}}
\index{saveXmlTree@{saveXmlTree}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{saveXmlTree()}{saveXmlTree()}}
{\footnotesize\ttfamily void Funcdata\+::save\+Xml\+Tree (\begin{DoxyParamCaption}\item[{ostream \&}]{s }\end{DoxyParamCaption}) const}



Save an X\+ML description of the p-\/code tree to stream. 

A single $<$ast$>$ tag is produced with children describing Varnodes, Pcode\+Ops, and basic blocks making up {\bfseries{this}} function\textquotesingle{}s current syntax tree. 
\begin{DoxyParams}{Parameters}
{\em s} & is the output stream \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classFuncdata_adc0c8b4dab63367913749e68fbd33789}\label{classFuncdata_adc0c8b4dab63367913749e68fbd33789}} 
\index{Funcdata@{Funcdata}!seenDeadcode@{seenDeadcode}}
\index{seenDeadcode@{seenDeadcode}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{seenDeadcode()}{seenDeadcode()}}
{\footnotesize\ttfamily void Funcdata\+::seen\+Deadcode (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classAddrSpace}{Addr\+Space}} $\ast$}]{spc }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Mark that dead Varnodes have been seen in a specific address space. 


\begin{DoxyParams}{Parameters}
{\em spc} & is the address space to mark \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classFuncdata_a15885a8369e2c43c8c7883a4fabd533e}\label{classFuncdata_a15885a8369e2c43c8c7883a4fabd533e}} 
\index{Funcdata@{Funcdata}!setBasicBlockRange@{setBasicBlockRange}}
\index{setBasicBlockRange@{setBasicBlockRange}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{setBasicBlockRange()}{setBasicBlockRange()}}
{\footnotesize\ttfamily void Funcdata\+::set\+Basic\+Block\+Range (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classBlockBasic}{Block\+Basic}} $\ast$}]{bb,  }\item[{const \mbox{\hyperlink{classAddress}{Address}} \&}]{beg,  }\item[{const \mbox{\hyperlink{classAddress}{Address}} \&}]{end }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Set the initial ownership range for the given basic block. 


\begin{DoxyParams}{Parameters}
{\em bb} & is the given basic block \\
\hline
{\em beg} & is the beginning \mbox{\hyperlink{classAddress}{Address}} of the owned code range \\
\hline
{\em end} & is the ending \mbox{\hyperlink{classAddress}{Address}} of the owned code range \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classFuncdata_ac40aef88ca7a101e4697df5e0ec5f605}\label{classFuncdata_ac40aef88ca7a101e4697df5e0ec5f605}} 
\index{Funcdata@{Funcdata}!setDeadCodeDelay@{setDeadCodeDelay}}
\index{setDeadCodeDelay@{setDeadCodeDelay}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{setDeadCodeDelay()}{setDeadCodeDelay()}}
{\footnotesize\ttfamily void Funcdata\+::set\+Dead\+Code\+Delay (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classAddrSpace}{Addr\+Space}} $\ast$}]{spc,  }\item[{int4}]{delay }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Set a delay before removing dead code for a specific address space. 


\begin{DoxyParams}{Parameters}
{\em spc} & is the specific address space \\
\hline
{\em delay} & is the number of passes to delay \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classFuncdata_a23bcddc7a3b959812f9a1660b39cc6ef}\label{classFuncdata_a23bcddc7a3b959812f9a1660b39cc6ef}} 
\index{Funcdata@{Funcdata}!setDoublePrecisRecovery@{setDoublePrecisRecovery}}
\index{setDoublePrecisRecovery@{setDoublePrecisRecovery}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{setDoublePrecisRecovery()}{setDoublePrecisRecovery()}}
{\footnotesize\ttfamily void Funcdata\+::set\+Double\+Precis\+Recovery (\begin{DoxyParamCaption}\item[{bool}]{val }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Toggle whether double precision analysis is used. 


\begin{DoxyParams}{Parameters}
{\em val} & is {\bfseries{true}} if double precision analysis is enabled \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classFuncdata_a84a9880613a03f3aea65acf3dd1343d6}\label{classFuncdata_a84a9880613a03f3aea65acf3dd1343d6}} 
\index{Funcdata@{Funcdata}!setInputVarnode@{setInputVarnode}}
\index{setInputVarnode@{setInputVarnode}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{setInputVarnode()}{setInputVarnode()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classVarnode}{Varnode}} $\ast$ Funcdata\+::set\+Input\+Varnode (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classVarnode}{Varnode}} $\ast$}]{vn }\end{DoxyParamCaption})}



Mark a \mbox{\hyperlink{classVarnode}{Varnode}} as an input to the function. 

An {\itshape input} \mbox{\hyperlink{classVarnode}{Varnode}} has a special designation within S\+SA form as not being defined by a p-\/code operation and is a formal input to the data-\/flow of the function. It is not necessarily a formal function parameter.

The given \mbox{\hyperlink{classVarnode}{Varnode}} to be marked is also returned unless there is an input \mbox{\hyperlink{classVarnode}{Varnode}} that already exists which overlaps the given \mbox{\hyperlink{classVarnode}{Varnode}}. If the Varnodes have the same size and storage address, the preexisting input \mbox{\hyperlink{classVarnode}{Varnode}} is returned instead. Otherwise an exception is thrown. 
\begin{DoxyParams}{Parameters}
{\em vn} & is the given \mbox{\hyperlink{classVarnode}{Varnode}} to mark as an input \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the marked \mbox{\hyperlink{classVarnode}{Varnode}} 
\end{DoxyReturn}
\mbox{\Hypertarget{classFuncdata_ac33bb4d59a0125d36710fe80453b9526}\label{classFuncdata_ac33bb4d59a0125d36710fe80453b9526}} 
\index{Funcdata@{Funcdata}!setJumptableRecovery@{setJumptableRecovery}}
\index{setJumptableRecovery@{setJumptableRecovery}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{setJumptableRecovery()}{setJumptableRecovery()}}
{\footnotesize\ttfamily void Funcdata\+::set\+Jumptable\+Recovery (\begin{DoxyParamCaption}\item[{bool}]{val }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Toggle whether {\bfseries{this}} is being used for jump-\/table recovery. 


\begin{DoxyParams}{Parameters}
{\em val} & is {\bfseries{true}} to indicate a jump-\/table is being recovered \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classFuncdata_af21c852eb9f606c5cd19fb2456927ecd}\label{classFuncdata_af21c852eb9f606c5cd19fb2456927ecd}} 
\index{Funcdata@{Funcdata}!setRestartPending@{setRestartPending}}
\index{setRestartPending@{setRestartPending}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{setRestartPending()}{setRestartPending()}}
{\footnotesize\ttfamily void Funcdata\+::set\+Restart\+Pending (\begin{DoxyParamCaption}\item[{bool}]{val }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Toggle whether analysis needs to be restarted for {\bfseries{this}} function. 


\begin{DoxyParams}{Parameters}
{\em val} & is {\bfseries{true}} if a reset is required \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classFuncdata_a96433773ee0126ce9a25b0970a6ef513}\label{classFuncdata_a96433773ee0126ce9a25b0970a6ef513}} 
\index{Funcdata@{Funcdata}!spacebase@{spacebase}}
\index{spacebase@{spacebase}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{spacebase()}{spacebase()}}
{\footnotesize\ttfamily void Funcdata\+::spacebase (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Mark registers that map to a virtual address space. 

This routine searches for an marks \mbox{\hyperlink{classVarnode}{Varnode}} objects, like stack-\/pointer registers, that are used as a base address for a virtual address space. Each \mbox{\hyperlink{classVarnode}{Varnode}} gets a special data-\/type and is marked so that Varnode\+::is\+Spacebase() returns {\bfseries{true}}. \mbox{\Hypertarget{classFuncdata_aaf4a89f4e3da37a4107992689f7b89ff}\label{classFuncdata_aaf4a89f4e3da37a4107992689f7b89ff}} 
\index{Funcdata@{Funcdata}!spacebaseConstant@{spacebaseConstant}}
\index{spacebaseConstant@{spacebaseConstant}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{spacebaseConstant()}{spacebaseConstant()}}
{\footnotesize\ttfamily void Funcdata\+::spacebase\+Constant (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} $\ast$}]{op,  }\item[{int4}]{slot,  }\item[{\mbox{\hyperlink{classSymbolEntry}{Symbol\+Entry}} $\ast$}]{entry,  }\item[{const \mbox{\hyperlink{classAddress}{Address}} \&}]{rampoint,  }\item[{uintb}]{origval,  }\item[{int4}]{origsize }\end{DoxyParamCaption})}



Convert a constant pointer into a {\itshape ram} C\+P\+U\+I\+\_\+\+P\+T\+R\+S\+UB. 

A constant known to be a pointer into an address space like {\bfseries{ram}} is converted into a \mbox{\hyperlink{classVarnode}{Varnode}} defined by C\+P\+U\+I\+\_\+\+P\+T\+R\+S\+UB, which triggers a \mbox{\hyperlink{classSymbol}{Symbol}} lookup at points during analysis. The constant must point to a known \mbox{\hyperlink{classSymbol}{Symbol}}.

The P\+T\+R\+S\+UB takes the constant 0 as its first input, which is marked as a {\itshape spacebase} to indicate this situation. The second input to P\+T\+R\+S\+UB becomes the offset to the \mbox{\hyperlink{classSymbol}{Symbol}} within the address space. An additional I\+N\+T\+\_\+\+S\+UB may be inserted to get from the start of the \mbox{\hyperlink{classSymbol}{Symbol}} to the address indicated by the original constant pointer. 
\begin{DoxyParams}{Parameters}
{\em op} & is the \mbox{\hyperlink{classPcodeOp}{Pcode\+Op}} referencing the constant pointer \\
\hline
{\em slot} & is the input slot of the constant pointer \\
\hline
{\em entry} & is the \mbox{\hyperlink{classSymbol}{Symbol}} being pointed (in)to \\
\hline
{\em rampoint} & is the constant pointer interpreted as an \mbox{\hyperlink{classAddress}{Address}} \\
\hline
{\em origval} & is the constant \\
\hline
{\em origsize} & is the size of the constant \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classFuncdata_a9f0c9d7c7fb4217731ae45f7848e4034}\label{classFuncdata_a9f0c9d7c7fb4217731ae45f7848e4034}} 
\index{Funcdata@{Funcdata}!spliceBlockBasic@{spliceBlockBasic}}
\index{spliceBlockBasic@{spliceBlockBasic}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{spliceBlockBasic()}{spliceBlockBasic()}}
{\footnotesize\ttfamily void Funcdata\+::splice\+Block\+Basic (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classBlockBasic}{Block\+Basic}} $\ast$}]{bl }\end{DoxyParamCaption})}



\mbox{\hyperlink{classMerge}{Merge}} the given basic block with the block it flows into. 

The given block must have a single output block, which will be removed. The given block has the p-\/code from the output block concatenated to its own, and it inherits the output block\textquotesingle{}s out edges. 
\begin{DoxyParams}{Parameters}
{\em bl} & is the given basic block \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classFuncdata_a0637a2c7f6a1e511284cfeecb4b0d475}\label{classFuncdata_a0637a2c7f6a1e511284cfeecb4b0d475}} 
\index{Funcdata@{Funcdata}!startProcessing@{startProcessing}}
\index{startProcessing@{startProcessing}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{startProcessing()}{startProcessing()}}
{\footnotesize\ttfamily void Funcdata\+::start\+Processing (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Start processing for this function. 

This routine does basic set-\/up for analyzing the function. In particular, it generates the raw p-\/code, builds basic blocks, and generates the call specification objects. \mbox{\Hypertarget{classFuncdata_a5ba1555023c49006ed39936b9a40aba4}\label{classFuncdata_a5ba1555023c49006ed39936b9a40aba4}} 
\index{Funcdata@{Funcdata}!switchEdge@{switchEdge}}
\index{switchEdge@{switchEdge}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{switchEdge()}{switchEdge()}}
{\footnotesize\ttfamily void Funcdata\+::switch\+Edge (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classFlowBlock}{Flow\+Block}} $\ast$}]{inblock,  }\item[{\mbox{\hyperlink{classBlockBasic}{Block\+Basic}} $\ast$}]{outbefore,  }\item[{\mbox{\hyperlink{classFlowBlock}{Flow\+Block}} $\ast$}]{outafter }\end{DoxyParamCaption})}



Switch an outgoing edge from the given {\itshape source} block to flow into another block. 

This does {\itshape not} adjust M\+U\+L\+T\+I\+E\+Q\+U\+AL data-\/flow. 
\begin{DoxyParams}{Parameters}
{\em inblock} & is the given {\itshape source} block \\
\hline
{\em outbefore} & is the other side of the desired edge \\
\hline
{\em outafter} & is the new destination block desired \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classFuncdata_aca583e76acc0a61bc30bd32461d25aee}\label{classFuncdata_aca583e76acc0a61bc30bd32461d25aee}} 
\index{Funcdata@{Funcdata}!syncVarnodesWithSymbols@{syncVarnodesWithSymbols}}
\index{syncVarnodesWithSymbols@{syncVarnodesWithSymbols}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{syncVarnodesWithSymbols()}{syncVarnodesWithSymbols()}}
{\footnotesize\ttfamily bool Funcdata\+::sync\+Varnodes\+With\+Symbols (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classScopeLocal}{Scope\+Local}} $\ast$}]{lm,  }\item[{bool}]{typesyes }\end{DoxyParamCaption})}



Update \mbox{\hyperlink{classVarnode}{Varnode}} properties based on (new) \mbox{\hyperlink{classSymbol}{Symbol}} information. 

Boolean properties {\bfseries{addrtied}}, {\bfseries{addrforce}}, and {\bfseries{nolocalalias}} for Varnodes are updated based on new \mbox{\hyperlink{classSymbol}{Symbol}} information they map to. The caller can elect to update data-\/type information as well, where Varnodes and their associated High\+Variables have their data-\/type finalized based symbols. 
\begin{DoxyParams}{Parameters}
{\em lm} & is the \mbox{\hyperlink{classSymbol}{Symbol}} scope within which to search for mapped Varnodes \\
\hline
{\em typesyes} & is {\bfseries{true}} if the caller wants to update data-\/types \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\bfseries{true}} if any \mbox{\hyperlink{classVarnode}{Varnode}} was updated 
\end{DoxyReturn}
\mbox{\Hypertarget{classFuncdata_aab7f940f85609d395283520eca3a71f0}\label{classFuncdata_aab7f940f85609d395283520eca3a71f0}} 
\index{Funcdata@{Funcdata}!totalReplace@{totalReplace}}
\index{totalReplace@{totalReplace}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{totalReplace()}{totalReplace()}}
{\footnotesize\ttfamily void Funcdata\+::total\+Replace (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classVarnode}{Varnode}} $\ast$}]{vn,  }\item[{\mbox{\hyperlink{classVarnode}{Varnode}} $\ast$}]{newvn }\end{DoxyParamCaption})}



Replace all read references to the first \mbox{\hyperlink{classVarnode}{Varnode}} with a second \mbox{\hyperlink{classVarnode}{Varnode}}. 


\begin{DoxyParams}{Parameters}
{\em vn} & is the first \mbox{\hyperlink{classVarnode}{Varnode}} (being replaced) \\
\hline
{\em newvn} & is the second \mbox{\hyperlink{classVarnode}{Varnode}} (the replacement) \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classFuncdata_a2934e1e4246d41a5e28f6fcb56acc937}\label{classFuncdata_a2934e1e4246d41a5e28f6fcb56acc937}} 
\index{Funcdata@{Funcdata}!totalReplaceConstant@{totalReplaceConstant}}
\index{totalReplaceConstant@{totalReplaceConstant}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{totalReplaceConstant()}{totalReplaceConstant()}}
{\footnotesize\ttfamily void Funcdata\+::total\+Replace\+Constant (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classVarnode}{Varnode}} $\ast$}]{vn,  }\item[{uintb}]{val }\end{DoxyParamCaption})}



Replace every read reference of the given \mbox{\hyperlink{classVarnode}{Varnode}} with a constant value. 

A new constant \mbox{\hyperlink{classVarnode}{Varnode}} is created for each read site. If there are any marker ops (M\+U\+L\+T\+I\+E\+Q\+U\+AL) a single C\+O\+PY op is inserted and the marker input is set to be the output of the C\+O\+PY. 
\begin{DoxyParams}{Parameters}
{\em vn} & is the given \mbox{\hyperlink{classVarnode}{Varnode}} \\
\hline
{\em val} & is the constant value to replace it with \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classFuncdata_a070edf06c2d300a7d6d1bda21189b477}\label{classFuncdata_a070edf06c2d300a7d6d1bda21189b477}} 
\index{Funcdata@{Funcdata}!transferVarnodeProperties@{transferVarnodeProperties}}
\index{transferVarnodeProperties@{transferVarnodeProperties}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{transferVarnodeProperties()}{transferVarnodeProperties()}}
{\footnotesize\ttfamily void Funcdata\+::transfer\+Varnode\+Properties (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classVarnode}{Varnode}} $\ast$}]{vn,  }\item[{\mbox{\hyperlink{classVarnode}{Varnode}} $\ast$}]{new\+Vn,  }\item[{int4}]{lsb\+Offset }\end{DoxyParamCaption})}



Copy properties from an existing \mbox{\hyperlink{classVarnode}{Varnode}} to a new \mbox{\hyperlink{classVarnode}{Varnode}}. 

The new \mbox{\hyperlink{classVarnode}{Varnode}} is assumed to overlap the storage of the existing \mbox{\hyperlink{classVarnode}{Varnode}}. Properties like boolean flags and {\itshape consume} bits are copied as appropriate. 
\begin{DoxyParams}{Parameters}
{\em vn} & is the existing \mbox{\hyperlink{classVarnode}{Varnode}} \\
\hline
{\em new\+Vn} & is the new \mbox{\hyperlink{classVarnode}{Varnode}} that has its properties set \\
\hline
{\em lsb\+Offset} & is the significance offset of the new \mbox{\hyperlink{classVarnode}{Varnode}} within the exising \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classFuncdata_a122718ad87c13b714676c61050461388}\label{classFuncdata_a122718ad87c13b714676c61050461388}} 
\index{Funcdata@{Funcdata}!truncatedFlow@{truncatedFlow}}
\index{truncatedFlow@{truncatedFlow}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{truncatedFlow()}{truncatedFlow()}}
{\footnotesize\ttfamily void Funcdata\+::truncated\+Flow (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classFuncdata}{Funcdata}} $\ast$}]{fd,  }\item[{const \mbox{\hyperlink{classFlowInfo}{Flow\+Info}} $\ast$}]{flow }\end{DoxyParamCaption})}



Generate a clone with truncated control-\/flow given a partial function. 

Existing p-\/code is cloned from another function whose flow has not been completely followed. Artificial halt operators are inserted wherever flow is incomplete and basic blocks are generated. 
\begin{DoxyParams}{Parameters}
{\em fd} & is the partial function to clone \\
\hline
{\em flow} & is partial function\textquotesingle{}s flow information \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classFuncdata_a19698f34a432f84d8cbe94f8e0ad20d4}\label{classFuncdata_a19698f34a432f84d8cbe94f8e0ad20d4}} 
\index{Funcdata@{Funcdata}!warning@{warning}}
\index{warning@{warning}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{warning()}{warning()}}
{\footnotesize\ttfamily void Funcdata\+::warning (\begin{DoxyParamCaption}\item[{const string \&}]{txt,  }\item[{const \mbox{\hyperlink{classAddress}{Address}} \&}]{ad }\end{DoxyParamCaption}) const}



Add a warning comment in the function body. 

The comment is added to the global database, indexed via its placement address and the entry address of the function. The emitter will attempt to place the comment before the source expression that maps most closely to the address. 
\begin{DoxyParams}{Parameters}
{\em txt} & is the string body of the comment \\
\hline
{\em ad} & is the placement address \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classFuncdata_a87967b12187406a7fdf311cc4b836118}\label{classFuncdata_a87967b12187406a7fdf311cc4b836118}} 
\index{Funcdata@{Funcdata}!warningHeader@{warningHeader}}
\index{warningHeader@{warningHeader}!Funcdata@{Funcdata}}
\doxysubsubsection{\texorpdfstring{warningHeader()}{warningHeader()}}
{\footnotesize\ttfamily void Funcdata\+::warning\+Header (\begin{DoxyParamCaption}\item[{const string \&}]{txt }\end{DoxyParamCaption}) const}



Add a warning comment as part of the function header. 

The warning will be emitted as part of the block comment printed right before the prototype. The comment is stored in the global comment database, indexed via the function\textquotesingle{}s entry address. 
\begin{DoxyParams}{Parameters}
{\em txt} & is the string body of the comment \\
\hline
\end{DoxyParams}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{funcdata_8hh}{funcdata.\+hh}}\item 
funcdata.\+cc\item 
funcdata\+\_\+block.\+cc\item 
funcdata\+\_\+op.\+cc\item 
funcdata\+\_\+varnode.\+cc\end{DoxyCompactItemize}
