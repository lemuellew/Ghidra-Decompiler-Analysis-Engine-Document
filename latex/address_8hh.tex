\hypertarget{address_8hh}{}\doxysection{address.\+hh File Reference}
\label{address_8hh}\index{address.hh@{address.hh}}


Classes for specifying addresses and other low-\/level constants.  


{\ttfamily \#include \char`\"{}space.\+hh\char`\"{}}\newline
Include dependency graph for address.\+hh\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{address_8hh__incl}
\end{center}
\end{figure}
This graph shows which files directly or indirectly include this file\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{address_8hh__dep__incl}
\end{center}
\end{figure}
\doxysubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{classAddress}{Address}}
\begin{DoxyCompactList}\small\item\em A low-\/level machine address for labelling bytes and data. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classSeqNum}{Seq\+Num}}
\begin{DoxyCompactList}\small\item\em A class for uniquely labelling and comparing Pcode\+Ops. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classRange}{Range}}
\begin{DoxyCompactList}\small\item\em A contiguous range of bytes in some address space. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classRangeList}{Range\+List}}
\begin{DoxyCompactList}\small\item\em A disjoint set of Ranges, possibly across multiple address spaces. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
uintb \mbox{\hyperlink{address_8hh_aae7b27e228c11138200b27f02831fc00}{calc\+\_\+mask}} (int4 size)
\begin{DoxyCompactList}\small\item\em Calculate a mask for a given byte size. \end{DoxyCompactList}\item 
uintb \mbox{\hyperlink{address_8hh_ac12878da77772a55518155dd325ede11}{pcode\+\_\+right}} (uintb val, int4 sa)
\item 
uintb \mbox{\hyperlink{address_8hh_af93e26c16ad497e986e09aedde194a93}{pcode\+\_\+left}} (uintb val, int4 sa)
\item 
uintb \mbox{\hyperlink{address_8hh_ae7e0d8ce5665eeb1f8bdc8fe054f9445}{minimalmask}} (uintb val)
\begin{DoxyCompactList}\small\item\em Calculate smallest mask that covers the given value. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{address_8hh_a78af4f83feb5be82e1cb2f6743792ba4}{signbit\+\_\+negative}} (uintb val, int4 size)
\begin{DoxyCompactList}\small\item\em Return true if the sign-\/bit is set. \end{DoxyCompactList}\item 
uintb \mbox{\hyperlink{address_8hh_a78cde28c4eada28e12fe0dbdfb840753}{uintb\+\_\+negate}} (uintb in, int4 size)
\begin{DoxyCompactList}\small\item\em Negate the {\itshape sized} value. \end{DoxyCompactList}\item 
uintb \mbox{\hyperlink{address_8hh_a6f16b447a8d8851178b1f0709c14bde6}{sign\+\_\+extend}} (uintb in, int4 sizein, int4 sizeout)
\begin{DoxyCompactList}\small\item\em Sign-\/extend a value between two byte sizes. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{address_8hh_abe0bd95db53e851e047b8273ba4fb59f}{sign\+\_\+extend}} (intb \&val, int4 bit)
\begin{DoxyCompactList}\small\item\em Sign extend above given bit. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{address_8hh_a953743448335ea450cbc58349ce1f0cf}{zero\+\_\+extend}} (intb \&val, int4 bit)
\begin{DoxyCompactList}\small\item\em Clear all bits above given bit. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{address_8hh_aedcacdf1dd5af3b58d59d76b8011d0f1}{byte\+\_\+swap}} (intb \&val, int4 size)
\begin{DoxyCompactList}\small\item\em Swap bytes in the given value. \end{DoxyCompactList}\item 
uintb \mbox{\hyperlink{address_8hh_ad080ab6270827c2a718582d0345d93a4}{byte\+\_\+swap}} (uintb val, int4 size)
\begin{DoxyCompactList}\small\item\em Return the given value with bytes swapped. \end{DoxyCompactList}\item 
int4 \mbox{\hyperlink{address_8hh_ac4d874e14dba4c4dabbbdc0a15653755}{leastsigbit\+\_\+set}} (uintb val)
\begin{DoxyCompactList}\small\item\em Return index of least significant bit set in given value. \end{DoxyCompactList}\item 
int4 \mbox{\hyperlink{address_8hh_aa894bdd40ffc8c7a6237e49062c62177}{mostsigbit\+\_\+set}} (uintb val)
\begin{DoxyCompactList}\small\item\em Return index of most significant bit set in given value. \end{DoxyCompactList}\item 
int4 \mbox{\hyperlink{address_8hh_a7ab13a468d3d8c590bbb3b0ae485a68a}{popcount}} (uintb val)
\begin{DoxyCompactList}\small\item\em Return the number of one bits in the given value. \end{DoxyCompactList}\item 
int4 \mbox{\hyperlink{address_8hh_a70e23e3408626b7fd45c1428774a245f}{count\+\_\+leading\+\_\+zeros}} (uintb val)
\begin{DoxyCompactList}\small\item\em Return the number of leading zero bits in the given value. \end{DoxyCompactList}\item 
uintb \mbox{\hyperlink{address_8hh_a2564fa4bd27c56892b3673fb40281abe}{coveringmask}} (uintb val)
\begin{DoxyCompactList}\small\item\em Return a mask that {\itshape covers} the given value. \end{DoxyCompactList}\item 
int4 \mbox{\hyperlink{address_8hh_a9971349a0c8643a0f9d1211f2e6aa3c0}{bit\+\_\+transitions}} (uintb val, int4 sz)
\begin{DoxyCompactList}\small\item\em Calculate the number of bit transitions in the sized value. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{address_8hh_adc3ee931652193c7dc50b842c3b4a3a6}{mult64to128}} (uint8 $\ast$res, uint8 x, uint8 y)
\begin{DoxyCompactList}\small\item\em Multiply 2 unsigned 64-\/bit values, producing a 128-\/bit value. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{address_8hh_a5cf8e9c3bc7603d16ba085596b113002}{unsigned\+Subtract128}} (uint8 $\ast$a, uint8 $\ast$b)
\begin{DoxyCompactList}\small\item\em Subtract (in-\/place) a 128-\/bit value from a base 128-\/value. \end{DoxyCompactList}\item 
int4 \mbox{\hyperlink{address_8hh_ad5b0ee7c5f0453d92bd8ca35876f2728}{unsigned\+Compare128}} (uint8 $\ast$a, uint8 $\ast$b)
\begin{DoxyCompactList}\small\item\em Compare two unsigned 128-\/bit values. \end{DoxyCompactList}\item 
int4 \mbox{\hyperlink{address_8hh_a09cc44c82138abf1b8fce558a3f0878d}{power2\+Divide}} (int4 n, uint8 divisor, uint8 \&q, uint8 \&r)
\begin{DoxyCompactList}\small\item\em Unsigned division of a power of 2 (upto 2$^\wedge$127) by a 64-\/bit divisor. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{address_8hh_af65db839ac7c389dab6cba2187c2e867}\label{address_8hh_af65db839ac7c389dab6cba2187c2e867}} 
uintb \mbox{\hyperlink{address_8hh_af65db839ac7c389dab6cba2187c2e867}{uintbmasks}} \mbox{[}$\,$\mbox{]}
\begin{DoxyCompactList}\small\item\em Precalculated masks indexed by size. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Classes for specifying addresses and other low-\/level constants. 

All addresses are absolute and there are are no registers in C\+P\+UI. However, all addresses are prefixed with an \char`\"{}immutable\char`\"{} pointer, which can specify a separate R\+AM space, a register space, an i/o space etc. Thus a translation from a real machine language will typically simulate registers by placing them in their own space, separate from R\+AM. Indirection (i.\+e. pointers) must be simulated through the L\+O\+AD and S\+T\+O\+RE ops. 

\doxysubsection{Function Documentation}
\mbox{\Hypertarget{address_8hh_a9971349a0c8643a0f9d1211f2e6aa3c0}\label{address_8hh_a9971349a0c8643a0f9d1211f2e6aa3c0}} 
\index{address.hh@{address.hh}!bit\_transitions@{bit\_transitions}}
\index{bit\_transitions@{bit\_transitions}!address.hh@{address.hh}}
\doxysubsubsection{\texorpdfstring{bit\_transitions()}{bit\_transitions()}}
{\footnotesize\ttfamily int4 bit\+\_\+transitions (\begin{DoxyParamCaption}\item[{uintb}]{val,  }\item[{int4}]{sz }\end{DoxyParamCaption})}



Calculate the number of bit transitions in the sized value. 

Treat {\bfseries{val}} as a constant of size {\bfseries{sz}}. Scanning across the bits of {\bfseries{val}} return the number of transitions (from 0-\/$>$1 or 1-\/$>$0) If there are 2 or less transitions, this is an indication of a bit flag or a mask 
\begin{DoxyParams}{Parameters}
{\em val} & is the given value \\
\hline
{\em sz} & is the size to treat the value as \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the number of transitions 
\end{DoxyReturn}
\mbox{\Hypertarget{address_8hh_aedcacdf1dd5af3b58d59d76b8011d0f1}\label{address_8hh_aedcacdf1dd5af3b58d59d76b8011d0f1}} 
\index{address.hh@{address.hh}!byte\_swap@{byte\_swap}}
\index{byte\_swap@{byte\_swap}!address.hh@{address.hh}}
\doxysubsubsection{\texorpdfstring{byte\_swap()}{byte\_swap()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void byte\+\_\+swap (\begin{DoxyParamCaption}\item[{intb \&}]{val,  }\item[{int4}]{size }\end{DoxyParamCaption})}



Swap bytes in the given value. 

Swap the least significant {\bfseries{size}} bytes in {\bfseries{val}} 
\begin{DoxyParams}{Parameters}
{\em val} & is a reference to the value to swap \\
\hline
{\em size} & is the number of bytes to swap \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{address_8hh_ad080ab6270827c2a718582d0345d93a4}\label{address_8hh_ad080ab6270827c2a718582d0345d93a4}} 
\index{address.hh@{address.hh}!byte\_swap@{byte\_swap}}
\index{byte\_swap@{byte\_swap}!address.hh@{address.hh}}
\doxysubsubsection{\texorpdfstring{byte\_swap()}{byte\_swap()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily uintb byte\+\_\+swap (\begin{DoxyParamCaption}\item[{uintb}]{val,  }\item[{int4}]{size }\end{DoxyParamCaption})}



Return the given value with bytes swapped. 

Swap the least significant {\bfseries{size}} bytes in {\bfseries{val}} 
\begin{DoxyParams}{Parameters}
{\em val} & is the value to swap \\
\hline
{\em size} & is the number of bytes to swap \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the swapped value 
\end{DoxyReturn}
\mbox{\Hypertarget{address_8hh_aae7b27e228c11138200b27f02831fc00}\label{address_8hh_aae7b27e228c11138200b27f02831fc00}} 
\index{address.hh@{address.hh}!calc\_mask@{calc\_mask}}
\index{calc\_mask@{calc\_mask}!address.hh@{address.hh}}
\doxysubsubsection{\texorpdfstring{calc\_mask()}{calc\_mask()}}
{\footnotesize\ttfamily uintb calc\+\_\+mask (\begin{DoxyParamCaption}\item[{int4}]{size }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Calculate a mask for a given byte size. 


\begin{DoxyParams}{Parameters}
{\em size} & is the desired size in bytes \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a value appropriate for masking off the first {\itshape size} bytes 
\end{DoxyReturn}
\mbox{\Hypertarget{address_8hh_a70e23e3408626b7fd45c1428774a245f}\label{address_8hh_a70e23e3408626b7fd45c1428774a245f}} 
\index{address.hh@{address.hh}!count\_leading\_zeros@{count\_leading\_zeros}}
\index{count\_leading\_zeros@{count\_leading\_zeros}!address.hh@{address.hh}}
\doxysubsubsection{\texorpdfstring{count\_leading\_zeros()}{count\_leading\_zeros()}}
{\footnotesize\ttfamily int4 count\+\_\+leading\+\_\+zeros (\begin{DoxyParamCaption}\item[{uintb}]{val }\end{DoxyParamCaption})}



Return the number of leading zero bits in the given value. 

Count the number of more significant zero bits before the most significant one bit in the representation of the given value; 
\begin{DoxyParams}{Parameters}
{\em val} & is the given value \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the number of zero bits 
\end{DoxyReturn}
\mbox{\Hypertarget{address_8hh_a2564fa4bd27c56892b3673fb40281abe}\label{address_8hh_a2564fa4bd27c56892b3673fb40281abe}} 
\index{address.hh@{address.hh}!coveringmask@{coveringmask}}
\index{coveringmask@{coveringmask}!address.hh@{address.hh}}
\doxysubsubsection{\texorpdfstring{coveringmask()}{coveringmask()}}
{\footnotesize\ttfamily uintb coveringmask (\begin{DoxyParamCaption}\item[{uintb}]{val }\end{DoxyParamCaption})}



Return a mask that {\itshape covers} the given value. 

Return smallest number of form 2$^\wedge$n-\/1, bigger or equal to the given value 
\begin{DoxyParams}{Parameters}
{\em val} & is the given value \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the mask 
\end{DoxyReturn}
\mbox{\Hypertarget{address_8hh_ac4d874e14dba4c4dabbbdc0a15653755}\label{address_8hh_ac4d874e14dba4c4dabbbdc0a15653755}} 
\index{address.hh@{address.hh}!leastsigbit\_set@{leastsigbit\_set}}
\index{leastsigbit\_set@{leastsigbit\_set}!address.hh@{address.hh}}
\doxysubsubsection{\texorpdfstring{leastsigbit\_set()}{leastsigbit\_set()}}
{\footnotesize\ttfamily int4 leastsigbit\+\_\+set (\begin{DoxyParamCaption}\item[{uintb}]{val }\end{DoxyParamCaption})}



Return index of least significant bit set in given value. 

The least significant bit is index 0. 
\begin{DoxyParams}{Parameters}
{\em val} & is the given value \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the index of the least significant set bit, or -\/1 if none are set 
\end{DoxyReturn}
\mbox{\Hypertarget{address_8hh_ae7e0d8ce5665eeb1f8bdc8fe054f9445}\label{address_8hh_ae7e0d8ce5665eeb1f8bdc8fe054f9445}} 
\index{address.hh@{address.hh}!minimalmask@{minimalmask}}
\index{minimalmask@{minimalmask}!address.hh@{address.hh}}
\doxysubsubsection{\texorpdfstring{minimalmask()}{minimalmask()}}
{\footnotesize\ttfamily uintb minimalmask (\begin{DoxyParamCaption}\item[{uintb}]{val }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Calculate smallest mask that covers the given value. 

Calculcate a mask that covers either the least significant byte, uint2, uint4, or uint8, whatever is smallest. 
\begin{DoxyParams}{Parameters}
{\em val} & is the given value \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the minimal mask 
\end{DoxyReturn}
\mbox{\Hypertarget{address_8hh_aa894bdd40ffc8c7a6237e49062c62177}\label{address_8hh_aa894bdd40ffc8c7a6237e49062c62177}} 
\index{address.hh@{address.hh}!mostsigbit\_set@{mostsigbit\_set}}
\index{mostsigbit\_set@{mostsigbit\_set}!address.hh@{address.hh}}
\doxysubsubsection{\texorpdfstring{mostsigbit\_set()}{mostsigbit\_set()}}
{\footnotesize\ttfamily int4 mostsigbit\+\_\+set (\begin{DoxyParamCaption}\item[{uintb}]{val }\end{DoxyParamCaption})}



Return index of most significant bit set in given value. 

The least significant bit is index 0. 
\begin{DoxyParams}{Parameters}
{\em val} & is the given value \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the index of the most significant set bit, or -\/1 if none are set 
\end{DoxyReturn}
\mbox{\Hypertarget{address_8hh_adc3ee931652193c7dc50b842c3b4a3a6}\label{address_8hh_adc3ee931652193c7dc50b842c3b4a3a6}} 
\index{address.hh@{address.hh}!mult64to128@{mult64to128}}
\index{mult64to128@{mult64to128}!address.hh@{address.hh}}
\doxysubsubsection{\texorpdfstring{mult64to128()}{mult64to128()}}
{\footnotesize\ttfamily void mult64to128 (\begin{DoxyParamCaption}\item[{uint8 $\ast$}]{res,  }\item[{uint8}]{x,  }\item[{uint8}]{y }\end{DoxyParamCaption})}



Multiply 2 unsigned 64-\/bit values, producing a 128-\/bit value. 

T\+O\+DO\+: Remove once we import a full multiprecision library. 
\begin{DoxyParams}{Parameters}
{\em res} & points to the result array (2 uint8 pieces) \\
\hline
{\em x} & is the first 64-\/bit value \\
\hline
{\em y} & is the second 64-\/bit value \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{address_8hh_af93e26c16ad497e986e09aedde194a93}\label{address_8hh_af93e26c16ad497e986e09aedde194a93}} 
\index{address.hh@{address.hh}!pcode\_left@{pcode\_left}}
\index{pcode\_left@{pcode\_left}!address.hh@{address.hh}}
\doxysubsubsection{\texorpdfstring{pcode\_left()}{pcode\_left()}}
{\footnotesize\ttfamily uintb pcode\+\_\+left (\begin{DoxyParamCaption}\item[{uintb}]{val,  }\item[{int4}]{sa }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Perform a C\+P\+U\+I\+\_\+\+I\+N\+T\+\_\+\+L\+E\+FT on the given val 
\begin{DoxyParams}{Parameters}
{\em val} & is the value to shift \\
\hline
{\em sa} & is the number of bits to shift \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the shifted value 
\end{DoxyReturn}
\mbox{\Hypertarget{address_8hh_ac12878da77772a55518155dd325ede11}\label{address_8hh_ac12878da77772a55518155dd325ede11}} 
\index{address.hh@{address.hh}!pcode\_right@{pcode\_right}}
\index{pcode\_right@{pcode\_right}!address.hh@{address.hh}}
\doxysubsubsection{\texorpdfstring{pcode\_right()}{pcode\_right()}}
{\footnotesize\ttfamily uintb pcode\+\_\+right (\begin{DoxyParamCaption}\item[{uintb}]{val,  }\item[{int4}]{sa }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Perform a C\+P\+U\+I\+\_\+\+I\+N\+T\+\_\+\+R\+I\+G\+HT on the given val 
\begin{DoxyParams}{Parameters}
{\em val} & is the value to shift \\
\hline
{\em sa} & is the number of bits to shift \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the shifted value 
\end{DoxyReturn}
\mbox{\Hypertarget{address_8hh_a7ab13a468d3d8c590bbb3b0ae485a68a}\label{address_8hh_a7ab13a468d3d8c590bbb3b0ae485a68a}} 
\index{address.hh@{address.hh}!popcount@{popcount}}
\index{popcount@{popcount}!address.hh@{address.hh}}
\doxysubsubsection{\texorpdfstring{popcount()}{popcount()}}
{\footnotesize\ttfamily int4 popcount (\begin{DoxyParamCaption}\item[{uintb}]{val }\end{DoxyParamCaption})}



Return the number of one bits in the given value. 

Count the number (population) bits set. 
\begin{DoxyParams}{Parameters}
{\em val} & is the given value \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the number of one bits 
\end{DoxyReturn}
\mbox{\Hypertarget{address_8hh_a09cc44c82138abf1b8fce558a3f0878d}\label{address_8hh_a09cc44c82138abf1b8fce558a3f0878d}} 
\index{address.hh@{address.hh}!power2Divide@{power2Divide}}
\index{power2Divide@{power2Divide}!address.hh@{address.hh}}
\doxysubsubsection{\texorpdfstring{power2Divide()}{power2Divide()}}
{\footnotesize\ttfamily int4 power2\+Divide (\begin{DoxyParamCaption}\item[{int4}]{n,  }\item[{uint8}]{divisor,  }\item[{uint8 \&}]{q,  }\item[{uint8 \&}]{r }\end{DoxyParamCaption})}



Unsigned division of a power of 2 (upto 2$^\wedge$127) by a 64-\/bit divisor. 

The result must be less than 2$^\wedge$64. The remainder is calculated. 
\begin{DoxyParams}{Parameters}
{\em n} & is the power of 2 for the numerand \\
\hline
{\em divisor} & is the 64-\/bit divisor \\
\hline
{\em q} & is the passed back 64-\/bit quotient \\
\hline
{\em r} & is the passed back 64-\/bit remainder \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 if successful, 1 if result is too big, 2 if divide by 0 
\end{DoxyReturn}
\mbox{\Hypertarget{address_8hh_abe0bd95db53e851e047b8273ba4fb59f}\label{address_8hh_abe0bd95db53e851e047b8273ba4fb59f}} 
\index{address.hh@{address.hh}!sign\_extend@{sign\_extend}}
\index{sign\_extend@{sign\_extend}!address.hh@{address.hh}}
\doxysubsubsection{\texorpdfstring{sign\_extend()}{sign\_extend()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void sign\+\_\+extend (\begin{DoxyParamCaption}\item[{intb \&}]{val,  }\item[{int4}]{bit }\end{DoxyParamCaption})}



Sign extend above given bit. 

Sign extend {\bfseries{val}} starting at {\bfseries{bit}} 
\begin{DoxyParams}{Parameters}
{\em val} & is a reference to the value to be sign-\/extended \\
\hline
{\em bit} & is the index of the bit to extend from (0=least significant bit) \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{address_8hh_a6f16b447a8d8851178b1f0709c14bde6}\label{address_8hh_a6f16b447a8d8851178b1f0709c14bde6}} 
\index{address.hh@{address.hh}!sign\_extend@{sign\_extend}}
\index{sign\_extend@{sign\_extend}!address.hh@{address.hh}}
\doxysubsubsection{\texorpdfstring{sign\_extend()}{sign\_extend()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily uintb sign\+\_\+extend (\begin{DoxyParamCaption}\item[{uintb}]{in,  }\item[{int4}]{sizein,  }\item[{int4}]{sizeout }\end{DoxyParamCaption})}



Sign-\/extend a value between two byte sizes. 

Take the first {\bfseries{sizein}} bytes of the given {\bfseries{in}} and sign-\/extend this to {\bfseries{sizeout}} bytes, keeping any more significant bytes zero 
\begin{DoxyParams}{Parameters}
{\em in} & is the given value \\
\hline
{\em sizein} & is the size to treat that value as an input \\
\hline
{\em sizeout} & is the size to sign-\/extend the value to \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the sign-\/extended value 
\end{DoxyReturn}
\mbox{\Hypertarget{address_8hh_a78af4f83feb5be82e1cb2f6743792ba4}\label{address_8hh_a78af4f83feb5be82e1cb2f6743792ba4}} 
\index{address.hh@{address.hh}!signbit\_negative@{signbit\_negative}}
\index{signbit\_negative@{signbit\_negative}!address.hh@{address.hh}}
\doxysubsubsection{\texorpdfstring{signbit\_negative()}{signbit\_negative()}}
{\footnotesize\ttfamily bool signbit\+\_\+negative (\begin{DoxyParamCaption}\item[{uintb}]{val,  }\item[{int4}]{size }\end{DoxyParamCaption})}



Return true if the sign-\/bit is set. 

Treat the given {\bfseries{val}} as a constant of {\bfseries{size}} bytes 
\begin{DoxyParams}{Parameters}
{\em val} & is the given value \\
\hline
{\em size} & is the size in bytes \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\bfseries{true}} if the constant (as sized) has its sign bit set 
\end{DoxyReturn}
\mbox{\Hypertarget{address_8hh_a78cde28c4eada28e12fe0dbdfb840753}\label{address_8hh_a78cde28c4eada28e12fe0dbdfb840753}} 
\index{address.hh@{address.hh}!uintb\_negate@{uintb\_negate}}
\index{uintb\_negate@{uintb\_negate}!address.hh@{address.hh}}
\doxysubsubsection{\texorpdfstring{uintb\_negate()}{uintb\_negate()}}
{\footnotesize\ttfamily uintb uintb\+\_\+negate (\begin{DoxyParamCaption}\item[{uintb}]{in,  }\item[{int4}]{size }\end{DoxyParamCaption})}



Negate the {\itshape sized} value. 

Treat the given {\bfseries{in}} as a constant of {\bfseries{size}} bytes. Negate this constant keeping the upper bytes zero. 
\begin{DoxyParams}{Parameters}
{\em in} & is the given value \\
\hline
{\em size} & is the size in bytes \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the negation of the sized constant 
\end{DoxyReturn}
\mbox{\Hypertarget{address_8hh_ad5b0ee7c5f0453d92bd8ca35876f2728}\label{address_8hh_ad5b0ee7c5f0453d92bd8ca35876f2728}} 
\index{address.hh@{address.hh}!unsignedCompare128@{unsignedCompare128}}
\index{unsignedCompare128@{unsignedCompare128}!address.hh@{address.hh}}
\doxysubsubsection{\texorpdfstring{unsignedCompare128()}{unsignedCompare128()}}
{\footnotesize\ttfamily int4 unsigned\+Compare128 (\begin{DoxyParamCaption}\item[{uint8 $\ast$}]{a,  }\item[{uint8 $\ast$}]{b }\end{DoxyParamCaption})}



Compare two unsigned 128-\/bit values. 

T\+O\+DO\+: Remove once we import a full multiprecision library. Given a first and second value, return -\/1, 0, or 1 depending on whether the first value is {\itshape less}, {\itshape equal}, or {\itshape greater} than the second value. 
\begin{DoxyParams}{Parameters}
{\em a} & is the first 128-\/bit value (as an array of 2 uint8 elements) \\
\hline
{\em b} & is the second 128-\/bit value \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the comparison code 
\end{DoxyReturn}
\mbox{\Hypertarget{address_8hh_a5cf8e9c3bc7603d16ba085596b113002}\label{address_8hh_a5cf8e9c3bc7603d16ba085596b113002}} 
\index{address.hh@{address.hh}!unsignedSubtract128@{unsignedSubtract128}}
\index{unsignedSubtract128@{unsignedSubtract128}!address.hh@{address.hh}}
\doxysubsubsection{\texorpdfstring{unsignedSubtract128()}{unsignedSubtract128()}}
{\footnotesize\ttfamily void unsigned\+Subtract128 (\begin{DoxyParamCaption}\item[{uint8 $\ast$}]{a,  }\item[{uint8 $\ast$}]{b }\end{DoxyParamCaption})}



Subtract (in-\/place) a 128-\/bit value from a base 128-\/value. 

The base value is altered in place. T\+O\+DO\+: Remove once we import a full multiprecision library. 
\begin{DoxyParams}{Parameters}
{\em a} & is the base 128-\/bit value being subtracted from in-\/place \\
\hline
{\em b} & is the other 128-\/bit value being subtracted \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{address_8hh_a953743448335ea450cbc58349ce1f0cf}\label{address_8hh_a953743448335ea450cbc58349ce1f0cf}} 
\index{address.hh@{address.hh}!zero\_extend@{zero\_extend}}
\index{zero\_extend@{zero\_extend}!address.hh@{address.hh}}
\doxysubsubsection{\texorpdfstring{zero\_extend()}{zero\_extend()}}
{\footnotesize\ttfamily void zero\+\_\+extend (\begin{DoxyParamCaption}\item[{intb \&}]{val,  }\item[{int4}]{bit }\end{DoxyParamCaption})}



Clear all bits above given bit. 

Zero extend {\bfseries{val}} starting at {\bfseries{bit}} 
\begin{DoxyParams}{Parameters}
{\em val} & is a reference to the value to be zero extended \\
\hline
{\em bit} & is the index of the bit to extend from (0=least significant bit) \\
\hline
\end{DoxyParams}
